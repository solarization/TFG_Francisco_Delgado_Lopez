\chapter{Código completo}

Todo el código que se muestra a continuación está disponible\ldots{}

\section{Constructores}
\label{sec:orgc396124}
\subsection{calcSol}
\label{sec:org55f1d16}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
calcSol <- function(lat, BTd,
                    sample = 'hour', BTi,
                    EoT = TRUE,
                    keep.night = TRUE,
                    method = 'michalsky')
{
    if(missing(BTd)) BTd <- truncDay(BTi)
    solD <- fSolD(lat, BTd, method = method) #daily values
    solI <- fSolI(solD = solD, sample = sample, #intradaily values
                  BTi = BTi, keep.night = keep.night,
                  EoT = EoT, method = method)

    if(!missing(BTi)){
        sample <- solI$Dates[2]-solI$Dates[1]
        sample <- format(sample)
    }

    solD[, lat := NULL]
    solI[, lat := NULL]
    result <- new('Sol',
                  lat = lat,
                  solD = solD,
                  solI = solI,
                  sample = sample,
                  method = method)
    return(result)
}
\end{lstlisting}
\subsection{calcG0}
\label{sec:orgb60d3e3}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
calcG0 <- function(lat,
                   modeRad='prom',
                   dataRad,
                   sample='hour',
                   keep.night=TRUE,
                   sunGeometry='michalsky',
                   corr, f, ...)
{

    if (missing(lat)) stop('lat missing. You must provide a latitude value.')

    stopifnot(modeRad %in% c('prom', 'aguiar','bd', 'bdI'))


###Datos de Radiacion
    if (missing(corr)){
        corr = switch(modeRad,
                      bd = 'CPR', #Correlation between Fd and Kt for daily values
                      aguiar = 'CPR', #Correlation between Fd and Kt for daily values
                      prom = 'Page',  #Correlation between Fd and Kt for monthly averages
                      bdI = 'BRL'     #Correlation between fd and kt for intraday values
                      )
    }

    if(is(dataRad, 'Meteo')){BD <- dataRad}
    else{
    BD <- switch(modeRad,
                 bd = {
                         if (!is.list(dataRad)) dataRad <- list(file=dataRad)
                         switch(class(dataRad$file)[1],
                                character={
                                    bd.default=list(file='', lat=lat)
                                    bd=modifyList(bd.default, dataRad)
                                    res <- do.call('readBDd', bd)
                                    res
                                },
                                data.table= ,
                                data.frame={
                                    bd.default=list(file='', lat=lat)
                                    bd=modifyList(bd.default, dataRad)
                                    res <- do.call('dt2Meteo', bd)
                                    res
                                },
                                zoo={
                                    bd.default=list(file='', lat=lat, source='')
                                    bd=modifyList(bd.default, dataRad)
                                    res <- do.call('zoo2Meteo', bd)
                                    res
                                })
                     }, #End of bd
                 prom = {
                     if (!is.list(dataRad)) dataRad <- list(G0dm=dataRad)
                     prom.default <- list(G0dm=numeric(), lat=lat)
                     prom = modifyList(prom.default, dataRad)
                     res <- do.call('readG0dm', prom)
                 }, #End of prom
                 aguiar = {
                     if (is.list(dataRad)) dataRad <- dataRad$G0dm
                     BTd <- fBTd(mode='serie')
                     solD <- fSolD(lat, BTd)
                     G0d <- markovG0(dataRad, solD)
                     res <- dt2Meteo(G0d, lat=lat, source='aguiar')
                 }, #End of aguiar
                 bdI = {
                     if (!is.list(dataRad)) dataRad <- list(file=dataRad)
                     switch(class(dataRad$file)[1],
                            character = {
                                bdI.default <- list(file='', lat=lat)
                                bdI <- modifyList(bdI.default, dataRad)
                                res <- do.call('readBDi', bdI)
                                res
                            },
                            data.table = ,
                            data.frame = {
                                bdI.default <- list(file='', lat=lat)
                                bdI <- modifyList(bdI.default, dataRad)
                                res <- do.call('dt2Meteo', bdI)
                                res
                            },
                            zoo = {
                                bdI.default <- list(file='', lat=lat, source='')
                                bdI <- modifyList(bdI.default, dataRad)
                                res <- do.call('zoo2Meteo', bdI)
                                res
                            },
                            stop('dataRad$file should be a character, a data.table, a data.frame or a zoo.')
                            )} #End of btI
                 )             #End of general switch    
    }


### Angulos solares y componentes de irradiancia
    if (modeRad=='bdI') {
        sol <- calcSol(lat, sample = sample,
                       BTi = indexD(BD), keep.night=keep.night, method=sunGeometry)
        compI <- fCompI(sol=sol, G0I=BD, corr=corr, f=f, ...)
        compD <- compI[, lapply(.SD, P2E, sol@sample),
                       .SDcols = c('G0', 'D0', 'B0'),
                       by = truncDay(Dates)]
        names(compD)[1] <- 'Dates'
        names(compD)[-1] <- paste(names(compD)[-1], 'd', sep = '')
        compD$Fd <- compD$D0d/compD$G0d
        compD$Kt <- compD$G0d/sol@solD$Bo0d
    } else { ##modeRad!='bdI'
        sol <- calcSol(lat, indexD(BD), sample = sample,
                       keep.night = keep.night, method = sunGeometry)
        compD<-fCompD(sol=sol, G0d=BD, corr=corr, f, ...)
        compI<-fCompI(sol=sol, compD=compD, ...)
    }

###Temperature

    Ta=switch(modeRad,
              bd={
                  if (all(c("TempMax","TempMin") %in% names(BD@data))) {
                      fTemp(sol, BD)
                  } else {
                      if ("Ta" %in% names(BD@data)) {
                          data.table(Dates = indexD(sol),
                                     Ta =BD@data$Ta)
                      } else {
                          warning('No temperature information available!')
                      }
                  }
              },
              bdI={
                  if ("Ta" %in% names(BD@data)) {
                      data.table(Dates = indexI(sol),
                                 Ta = BD@data$Ta)
                  } else {
                      warning('No temperature information available!')
                  }
              },
              prom={
                  if ("Ta" %in% names(BD@data)) {
                      data.table(Dates = indexD(sol),
                                 Ta = BD@data$Ta)
                  } else {
                      warning('No temperature information available!')
                  }                  
              },
              aguiar={ 
                  data.table(Dates = indexI(sol),
                             Ta = BD@data$Ta)
              }
              )

###Medias mensuales y anuales
    nms <- c('G0d', 'D0d', 'B0d')
    G0dm <- compD[, lapply(.SD/1000, mean, na.rm = TRUE),
                  .SDcols = nms,
                  by = .(month(Dates), year(Dates))]

    if(modeRad == 'prom'){
        G0dm[, DayOfMonth := DOM(G0dm)]
        G0y <- G0dm[, lapply(.SD*DayOfMonth, sum, na.rm = TRUE),
                    .SDcols = nms,
                    by = .(Dates = year)]
        G0dm[, DayOfMonth := NULL]        
    } else{
        G0y <- compD[, lapply(.SD/1000, sum, na.rm = TRUE),
                     .SDcols = nms,
                     by = .(Dates = year(Dates))]
    }
    G0dm[, Dates := paste(month.abb[month], year, sep = '. ')]
    G0dm[, c('month', 'year') := NULL]
    setcolorder(G0dm, 'Dates')

###Result
    result <- new(Class='G0',
                  BD,        #G0 contains "Meteo"
                  sol,       #G0 contains 'Sol'
                  G0D=compD, #results of fCompD
                  G0dm=G0dm, #monthly means
                  G0y=G0y,   #yearly values
                  G0I=compI, #results of fCompD
                  Ta=Ta      #ambient temperature
                  )
    return(result)
}
\end{lstlisting}
\subsection{calcGef}
\label{sec:org5f92dfc}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
calcGef<-function(lat,
                  modeTrk='fixed',      #c('two','horiz','fixed')
                  modeRad='prom', 
                  dataRad,
                  sample='hour',
                  keep.night=TRUE,
                  sunGeometry='michalsky',
                  corr, f,
                  betaLim=90, beta=abs(lat)-10, alfa=0,
                  iS=2, alb=0.2, horizBright=TRUE, HCPV=FALSE,
                  modeShd='',    #modeShd=c('area','bt','prom')
                  struct=list(), #list(W=23.11, L=9.8, Nrow=2, Ncol=8), 
                  distances=data.frame(),#data.table(Lew=40, Lns=30, H=0)){
                  ...){

    stopifnot(is.list(struct), is.data.frame(distances))

    if (('bt' %in% modeShd) & (modeTrk!='horiz')) {
        modeShd[which(modeShd=='bt')]='area'
        warning('backtracking is only implemented for modeTrk=horiz')}

    if (modeRad!='prev'){ #not use a prev calculation
        radHoriz <- calcG0(lat=lat, modeRad=modeRad,
                           dataRad=dataRad,
                           sample=sample, keep.night=keep.night,
                           sunGeometry=sunGeometry,
                           corr=corr, f=f, ...)
    } else {                          #use a prev calculation
        radHoriz <- as(dataRad, 'G0') 
    } 

### Inclined and effective radiation
    BT=("bt" %in% modeShd) 
    angGen <- fTheta(radHoriz, beta, alfa, modeTrk, betaLim, BT, struct, distances)
    inclin <- fInclin(radHoriz, angGen, iS, alb, horizBright, HCPV)

### Daily, monthly and yearly values
    by <- radHoriz@sample
    nms <- c('Bo', 'Bn', 'G', 'D', 'B', 'Gef', 'Def', 'Bef')
    nmsd <- paste(nms, 'd', sep = '')


    if(radHoriz@type == 'prom'){
        Gefdm <- inclin[, lapply(.SD/1000, P2E, by),
                        .SDcols = nms,
                        by = .(month(Dates), year(Dates))]
        names(Gefdm)[-c(1,2)] <- nmsd
        GefD <- Gefdm[, .SD*1000,
                      .SDcols = nmsd,
                      by = .(Dates = indexD(radHoriz))]

        Gefdm[, DayOfMonth := DOM(Gefdm)]
        Gefy <- Gefdm[, lapply(.SD*DayOfMonth, sum, na.rm = TRUE),
                      .SDcols = nmsd,
                      by = .(Dates = year)]
        Gefdm[, DayOfMonth := NULL]
    } else{
        GefD <- inclin[, lapply(.SD, P2E, by),
                       .SDcols = nms,
                       by = .(Dates = truncDay(Dates))]
        names(GefD)[-1] <- nmsd

        Gefdm <- GefD[, lapply(.SD/1000, mean, na.rm = TRUE),
                      .SDcols = nmsd,
                      by = .(month(indexD(radHoriz)), year(indexD(radHoriz)))]
        Gefy <- GefD[, lapply(.SD/1000, sum, na.rm = TRUE),
                     .SDcols = nmsd,
                     by = .(Dates = year(indexD(radHoriz)))]
    }

    Gefdm[, Dates := paste(month.abb[month], year, sep = '. ')]
    Gefdm[, c('month', 'year') := NULL]
    setcolorder(Gefdm, 'Dates')

###Resultado antes de sombras
    result0=new('Gef',
                radHoriz,                           #Gef contains 'G0'
                Theta=angGen,
                GefD=GefD,
                Gefdm=Gefdm,
                Gefy=Gefy,
                GefI=inclin,
                iS=iS,
                alb=alb,
                modeTrk=modeTrk,
                modeShd=modeShd,
                angGen=list(alfa=alfa, beta=beta, betaLim=betaLim),
                struct=struct,
                distances=distances
                )
###Shadows
    if (isTRUE(modeShd == "") ||        #If modeShd=='' there is no shadow calculation
        ('bt' %in% modeShd)) {            #nor if there is backtracking
        return(result0)
    } else {
        result <- calcShd(result0, modeTrk, modeShd, struct, distances)
        return(result)
    }
}
\end{lstlisting}
\subsection{prodGCPV}
\label{sec:org3f1038d}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
prodGCPV<-function(lat,
                   modeTrk='fixed', 
                   modeRad='prom',
                   dataRad,
                   sample='hour',
                   keep.night=TRUE,
                   sunGeometry='michalsky',
                   corr, f,
                   betaLim=90, beta=abs(lat)-10, alfa=0,
                   iS=2, alb=0.2, horizBright=TRUE, HCPV=FALSE,
                   module=list(), 
                   generator=list(),
                   inverter=list(), 
                   effSys=list(), 
                   modeShd='',    
                   struct=list(), 
                   distances=data.table(),
                   ...){

    stopifnot(is.list(module),
              is.list(generator),
              is.list(inverter),
              is.list(effSys),
              is.list(struct),
              is.data.table(distances))

  if (('bt' %in% modeShd) & (modeTrk!='horiz')) {
      modeShd[which(modeShd=='bt')]='area'
      warning('backtracking is only implemented for modeTrk=horiz')}

    if (modeRad!='prev'){ #We do not use a previous calculation

    radEf<-calcGef(lat=lat, modeTrk=modeTrk, modeRad=modeRad,
                   dataRad=dataRad,
                   sample=sample, keep.night=keep.night,
                   sunGeometry=sunGeometry,
                   corr=corr, f=f,
                   betaLim=betaLim, beta=beta, alfa=alfa,
                   iS=iS, alb=alb, horizBright=horizBright, HCPV=HCPV,
                   modeShd=modeShd, struct=struct, distances=distances, ...)

  } else { #We use a previous calcG0, calcGef or prodGCPV calculation.

      stopifnot(class(dataRad) %in% c('G0', 'Gef', 'ProdGCPV'))
      radEf <- switch(class(dataRad),
                      G0=calcGef(lat=lat,
                                 modeTrk=modeTrk, modeRad='prev',
                                 dataRad=dataRad,
                                 betaLim=betaLim, beta=beta, alfa=alfa,
                                 iS=iS, alb=alb, horizBright=horizBright, HCPV=HCPV,
                                 modeShd=modeShd, struct=struct, distances=distances, ...),
                      Gef=dataRad,
                      ProdGCPV=as(dataRad, 'Gef')
                      )
  }


    ##Production
    prodI<-fProd(radEf,module,generator,inverter,effSys)
    module=attr(prodI, 'module')
    generator=attr(prodI, 'generator')
    inverter=attr(prodI, 'inverter')
    effSys=attr(prodI, 'effSys')

    ##Calculation of daily, monthly and annual values
    Pg=generator$Pg #Wp

    by <- radEf@sample
    nms1 <- c('Pac', 'Pdc')
    nms2 <- c('Eac', 'Edc', 'Yf')


    if(radEf@type == 'prom'){
        prodDm <- prodI[, lapply(.SD/1000, P2E, by),
                        .SDcols = nms1,
                        by = .(month(Dates), year(Dates))]
        names(prodDm)[-c(1,2)] <- nms2[-3]
        prodDm[, Yf := Eac/(Pg/1000)]
        prodD <- prodDm[, .SD*1000,
                        .SDcols = nms2,
                        by = .(Dates = indexD(radEf))]
        prodD[, Yf := Yf/1000]

        prodDm[, DayOfMonth := DOM(prodDm)]
        prody <- prodDm[, lapply(.SD*DayOfMonth, sum, na.rm = TRUE),
                        .SDcols = nms2,
                        by = .(Dates = year)]
        prodDm[, DayOfMonth := NULL]
    } else {
        prodD <- prodI[, lapply(.SD, P2E, by),
                       .SDcols = nms1,
                       by = .(Dates = truncDay(Dates))]
        names(prodD)[-1] <- nms2[-3]
        prodD[, Yf := Eac/Pg]

        prodDm <- prodD[, lapply(.SD/1000, mean, na.rm = TRUE),
                        .SDcols = nms2,
                        by = .(month(Dates), year(Dates))]
        prodDm[, Yf := Yf * 1000]
        prody <- prodD[, lapply(.SD/1000, sum, na.rm = TRUE),
                       .SDcols = nms2,
                       by = .(Dates = year(Dates))]
        prody[, Yf := Yf * 1000]
    }

    prodDm[, Dates := paste(month.abb[month], year, sep = '. ')]
    prodDm[, c('month', 'year') := NULL]
    setcolorder(prodDm, 'Dates')

    result <- new('ProdGCPV',
                  radEf,                  #contains 'Gef'
                  prodD=prodD,
                  prodDm=prodDm,
                  prody=prody,
                  prodI=prodI,
                  module=module,
                  generator=generator,
                  inverter=inverter,
                  effSys=effSys
                  )
}
\end{lstlisting}
\subsection{prodPVPS}
\label{sec:org08c0b77}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
prodPVPS<-function(lat, 
                   modeTrk='fixed', 
                   modeRad='prom', 
                   dataRad,
                   sample='hour',
                   keep.night=TRUE,
                   sunGeometry='michalsky',
                   corr, f,
                   betaLim=90, beta=abs(lat)-10, alfa=0,
                   iS=2, alb=0.2, horizBright=TRUE, HCPV=FALSE,
                   pump , H, 
                   Pg, converter= list(), #Pnom=Pg, Ki=c(0.01,0.025,0.05)),
                   effSys=list(),
                   ...){

    stopifnot(is.list(converter),
              is.list(effSys))

    if (modeRad!='prev'){ #We do not use a previous calculation

        radEf<-calcGef(lat=lat, modeTrk=modeTrk, modeRad=modeRad,
                       dataRad=dataRad,
                       sample=sample, keep.night=keep.night,
                       sunGeometry=sunGeometry,
                       corr=corr, f=f,
                       betaLim=betaLim, beta=beta, alfa=alfa,
                       iS=iS, alb=alb, horizBright=horizBright, HCPV=HCPV,
                   modeShd='', ...)

    } else { #We use a previous calculation of calcG0, calcGef or prodPVPS
        stopifnot(class(dataRad) %in% c('G0', 'Gef', 'ProdPVPS'))
        radEf <- switch(class(dataRad),
                        G0=calcGef(lat=lat, 
                                   modeTrk=modeTrk, modeRad='prev',
                      dataRad=dataRad,
                      betaLim=betaLim, beta=beta, alfa=alfa,
                      iS=iS, alb=alb, horizBright=horizBright, HCPV=HCPV,
                      modeShd='', ...),
                      Gef=dataRad,
                      ProdPVPS=as(dataRad, 'Gef')
                      )
    }

###Electric production
    converter.default=list(Ki = c(0.01,0.025,0.05), Pnom=Pg)
    converter=modifyList(converter.default, converter)

    effSys.default=list(ModQual=3,ModDisp=2,OhmDC=1.5,OhmAC=1.5,MPP=1,TrafoMT=1,Disp=0.5)
    effSys=modifyList(effSys.default, effSys)

    TONC=47
    Ct=(TONC-20)/800
    lambda=0.0045
    Gef=radEf@GefI$Gef
    night=radEf@solI$night
    Ta=radEf@Ta$Ta

    Tc=Ta+Ct*Gef
    Pdc=Pg*Gef/1000*(1-lambda*(Tc-25))
    Pdc[is.na(Pdc)]=0 #Necessary for the functions provided by fPump
    PdcN=with(effSys,
              Pdc/converter$Pnom*(1-ModQual/100)*(1-ModDisp/100)*(1-OhmDC/100)
              )
    PacN=with(converter,{
        A=Ki[3]
        B=Ki[2]+1
        C=Ki[1]-(PdcN)
        ##AC power normalized to the inverter
        result=(-B+sqrt(B^2-4*A*C))/(2*A)
    })
    PacN[PacN<0]<-0

    Pac=with(converter,
             PacN*Pnom*(1-effSys$OhmAC/100))
    Pdc=PdcN*converter$Pnom*(Pac>0)


###Pump
    fun<-fPump(pump=pump, H=H)
    ##I limit power to the pump operating range.
    rango=with(fun,Pac>=lim[1] & Pac<=lim[2]) 
    Pac[!rango]<-0
    Pdc[!rango]<-0
    prodI=data.table(Pac=Pac,Pdc=Pdc,Q=0,Pb=0,Ph=0,f=0)	
    prodI=within(prodI,{
        Q[rango]<-fun$fQ(Pac[rango])
        Pb[rango]<-fun$fPb(Pac[rango])
        Ph[rango]<-fun$fPh(Pac[rango])
        f[rango]<-fun$fFreq(Pac[rango])
        etam=Pb/Pac
        etab=Ph/Pb
    })

    prodI[night,]<-NA
    prodI[, Dates := indexI(radEf)]
    setcolorder(prodI, c('Dates', names(prodI)[-length(prodI)]))

###daily, monthly and yearly values

    by <- radEf@sample

    if(radEf@type == 'prom'){
        prodDm <- prodI[, .(Eac = P2E(Pac, by)/1000,
                            Qd = P2E(Q, by)),
                        by = .(month(Dates), year(Dates))]
        prodDm[, Yf := Eac/(Pg/1000)]

        prodD <- prodDm[, .(Eac = Eac*1000,
                            Qd,
                            Yf),
                        by = .(Dates = indexD(radEf))]

        prodDm[, DayOfMonth := DOM(prodDm)]

        prody <- prodDm[, lapply(.SD*DayOfMonth, sum, na.rm = TRUE),
                        .SDcols = c('Eac', 'Qd', 'Yf'),
                        by = .(Dates = year)]
        prodDm[, DayOfMonth := NULL]
    } else {
        prodD <- prodI[, .(Eac = P2E(Pac, by)/1000,
                           Qd = P2E(Q, by)),
                       by = .(Dates = truncDay(Dates))]
        prodD[, Yf := Eac/Pg*1000]

        prodDm <- prodD[, lapply(.SD, mean, na.rm = TRUE),
                        .SDcols = c('Eac','Qd', 'Yf'),
                        by = .(month(Dates), year(Dates))]
        prody <- prodD[, lapply(.SD, sum, na.rm = TRUE),
                       .SDcols = c('Eac', 'Qd', 'Yf'),
                       by = .(Dates = year(Dates))]

    }

    prodDm[, Dates := paste(month.abb[month], year, sep = '. ')]
    prodDm[, c('month', 'year') := NULL]
    setcolorder(prodDm, 'Dates')

    result <- new('ProdPVPS',
                  radEf,                  #contains 'Gef'
                  prodD=prodD,
                  prodDm=prodDm,
                  prody=prody,
                  prodI=prodI,
                  pump=pump,
                  H=H,
                  Pg=Pg,
                  converter=converter,
                  effSys=effSys
                )
}
\end{lstlisting}
\subsection{calcShd}
\label{sec:org3e24759}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
calcShd<-function(radEf,##class='Gef'
                  modeTrk='fixed',     #c('two','horiz','fixed')
                  modeShd='prom',      #modeShd=c('area','bt','prom')
                  struct=list(), #list(W=23.11, L=9.8, Nrow=2, Ncol=8), 
                  distances=data.frame() #data.table(Lew=40, Lns=30, H=0)){
                  )
{
    stopifnot(is.list(struct), is.data.frame(distances))

    ##For now I only use modeShd = 'area'
    ##With different modeShd (to be defined) I will be able to calculate Gef in a different way
    ##See macagnan thesis
    prom=("prom"  %in%  modeShd)
    prev <- as.data.tableI(radEf, complete=TRUE)
    ## shadow calculations
    sol <- data.table(AzS = prev$AzS,
                      AlS = prev$AlS)
    theta <- radEf@Theta
    AngGen <- data.table(theta, sol)
    FS <- fSombra(AngGen, distances, struct, modeTrk, prom)
    ## irradiance calculation
    gef0 <- radEf@GefI
    Bef0 <- gef0$Bef
    Dcef0 <- gef0$Dcef
    Gef0 <- gef0$Gef
    Dief0 <- gef0$Dief
    Ref0 <- gef0$Ref
    ## calculation
    Bef <- Bef0*(1-FS)
    Dcef <- Dcef0*(1-FS)
    Def <- Dief0+Dcef
    Gef <- Dief0+Ref0+Bef+Dcef #Including shadows
    ##Change names
    nms <- c('Gef', 'Def', 'Dcef', 'Bef')
    nmsIndex <- which(names(gef0) %in% nms)
    names(gef0)[nmsIndex]<- paste(names(gef0)[nmsIndex], '0', sep='')
    GefShd <- gef0
    GefShd[, c(nms, 'FS') := .(Gef, Def, Dcef, Bef, FS)]

    ## daily, monthly and yearly values
    by <- radEf@sample
    nms <- c('Gef0', 'Def0', 'Bef0', 'G', 'D', 'B', 'Gef', 'Def', 'Bef')
    nmsd <- paste(nms, 'd', sep = '')

    Gefdm <- GefShd[, lapply(.SD/1000, P2E, by),
                    by = .(month(truncDay(Dates)), year(truncDay(Dates))),
                    .SDcols = nms]
    names(Gefdm)[-c(1, 2)] <- nmsd

    if(radEf@type == 'prom'){
        GefD <- Gefdm[, .SD[, -c(1, 2)] * 1000,
                      .SDcols = nmsd,
                      by = .(Dates = indexD(radEf))] 

        Gefdm[, DayOfMonth := DOM(Gefdm)]

        Gefy <- Gefdm[, lapply(.SD*DayOfMonth, sum, na.rm = TRUE),
                      .SDcols = nmsd,
                      by = .(Dates = year)]
        Gefdm[, DayOfMonth := NULL]
    } else{    
        GefD <- GefShd[, lapply(.SD/1000, P2E, by),
                       .SDcols = nms,
                       by = .(Dates = truncDay(Dates))]
        names(GefD)[-1] <- nmsd

        Gefy <- GefD[, lapply(.SD[, -1], sum, na.rm = TRUE),
                     .SDcols = nmsd,
                     by = .(Dates = year(Dates))]
    }

    Gefdm[, Dates := paste(month.abb[month], year, sep = '. ')]
    Gefdm[, c('month', 'year') := NULL]
    setcolorder(Gefdm, c('Dates', names(Gefdm)[-length(Gefdm)]))

    ## Object of class Gef
    ## modifying the 'modeShd', 'GefI', 'GefD', 'Gefdm', and 'Gefy' slots
    ## from the original radEf object
    radEf@modeShd=modeShd
    radEf@GefI=GefShd
    radEf@GefD=GefD
    radEf@Gefdm=Gefdm
    radEf@Gefy=Gefy
    return(radEf)
}
\end{lstlisting}
\subsection{optimShd}
\label{sec:org77b594c}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
optimShd<-function(lat,
                   modeTrk='fixed', 
                   modeRad='prom', 
                   dataRad,
                   sample='hour',
                   keep.night=TRUE,
                   sunGeometry='michalsky',
                   betaLim=90, beta=abs(lat)-10, alfa=0,
                   iS=2, alb=0.2, HCPV=FALSE,
                   module=list(), 
                   generator=list(),
                   inverter=list(), 
                   effSys=list(), 
                   modeShd='',    
                   struct=list(), 
                   distances=data.table(),
                   res=2,      #resolution, distance spacing
                   prog=TRUE){ #Drawing progress bar

    if (('bt' %in% modeShd) & (modeTrk!='horiz')) {
        modeShd[which(modeShd=='bt')]='area'
        warning('backtracking is only implemented for modeTrk=horiz')}

    ##I save function arguments for later use

    listArgs<-list(lat=lat, modeTrk=modeTrk, modeRad=modeRad,
                   dataRad=dataRad,
                   sample=sample, keep.night=keep.night,
                   sunGeometry=sunGeometry,
                   betaLim=betaLim, beta=beta, alfa=alfa,
                   iS=iS, alb=alb, HCPV=HCPV,
                   module=module, generator=generator,
                   inverter=inverter, effSys=effSys,
                   modeShd=modeShd, struct=struct,
                   distances=data.table(Lew=NA, Lns=NA, D=NA))


    ##I think network on which I will do the calculations
    Red=switch(modeTrk,
               horiz=with(distances,
                          data.table(Lew=seq(Lew[1],Lew[2],by=res),
                                     H=0)),
               two=with(distances,
                        data.table(
                        expand.grid(Lew=seq(Lew[1],Lew[2],by=res),
                                    Lns=seq(Lns[1],Lns[2],by=res),
                                    H=0))),
               fixed=with(distances,
                          data.table(D=seq(D[1],D[2],by=res),
                                     H=0))
    )

    casos<-dim(Red)[1] #Number of possibilities to study

    ##I prepare the progress bar
    if (prog) {pb <- txtProgressBar(min = 0, max = casos+1, style = 3)
        setTxtProgressBar(pb, 0)}

###Calculations	
    ##Reference: No shadows	
    listArgs0 <- modifyList(listArgs,
                            list(modeShd='', struct=NULL, distances=NULL) )
    Prod0<-do.call(prodGCPV, listArgs0)
    YfAnual0=mean(Prod0@prody$Yf) #I use mean in case there are several years
    if (prog) {setTxtProgressBar(pb, 1)}

    ##The loop begins

    ##I create an empty vector of the same length as the cases to be studied
    YfAnual<-numeric(casos) 

    BT=('bt' %in% modeShd)
    if (BT) { ##There is backtracking, then I must start from horizontal radiation.
        RadBT <- as(Prod0, 'G0')
        for (i in seq_len(casos)){
            listArgsBT <- modifyList(listArgs,
                                     list(modeRad='prev', dataRad=RadBT,
                                          distances=Red[i,]))
            prod.i <- do.call(prodGCPV, listArgsBT)
            YfAnual[i]=mean(prod.i@prody$Yf)
            if (prog) {setTxtProgressBar(pb, i+1)}
        }
    } else {
        prom=('prom' %in% modeShd)
        for (i in seq_len(casos)){
            Gef0=as(Prod0, 'Gef')
            GefShd=calcShd(Gef0, modeTrk=modeTrk, modeShd=modeShd,
                           struct=struct, distances=Red[i,])
            listArgsShd <- modifyList(listArgs,
                                      list(modeRad='prev', dataRad=GefShd)
                                      )
            prod.i <- do.call(prodGCPV, listArgsShd)
            YfAnual[i]=mean(prod.i@prody$Yf)
            if (prog) {setTxtProgressBar(pb, i+1)}
        }
    }
    if (prog) {close(pb)}


###Results
    FS=1-YfAnual/YfAnual0
    GRR=switch(modeTrk,
               two=with(Red,Lew*Lns)/with(struct,L*W),
               fixed=Red$D/struct$L,
               horiz=Red$Lew/struct$L)
    SombraDF=data.table(Red,GRR,FS,Yf=YfAnual)
    FS.loess=switch(modeTrk,
                    two=loess(FS~Lew*Lns,data=SombraDF),
                    horiz=loess(FS~Lew,data=SombraDF),
                    fixed=loess(FS~D,data=SombraDF))
    Yf.loess=switch(modeTrk,
                    two=loess(Yf~Lew*Lns,data=SombraDF),
                    horiz=loess(Yf~Lew,data=SombraDF),
                    fixed=loess(Yf~D,data=SombraDF))
    result <- new('Shade',
                  Prod0, ##contains ProdGCPV
                  FS=FS,
                  GRR=GRR,
                  Yf=YfAnual,
                  FS.loess=FS.loess,
                  Yf.loess=Yf.loess,
                  modeShd=modeShd,
                  struct=struct,
                  distances=Red,
                  res=res
                  )
    result
}
\end{lstlisting}
\subsection{meteoReaders}
\label{sec:orgbd2d198}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
#### monthly means of irradiation ####
readG0dm <- function(G0dm, Ta = 25, lat = 0,
                     year = as.POSIXlt(Sys.Date())$year + 1900,
                     promDays = c(17, 14, 15, 15, 15, 10, 18, 18, 18, 19, 18, 13),
                     source = '')
{
    if(missing(lat)){lat <- 0}
    Dates <- as.IDate(paste(year, 1:12, promDays, sep = '-'), tz = 'UTC')
    G0dm.dt <- data.table(Dates = Dates,
                          G0d = G0dm,
                          Ta = Ta)
    setkey(G0dm.dt, 'Dates')
    results <- new(Class = 'Meteo',
                   latm = lat,
                   data = G0dm.dt,
                   type = 'prom',
                   source = source)
}

#### file to Meteo (daily) ####
readBDd <- function(file, lat,
                   format = "%d/%m/%Y",header = TRUE,
                   fill = TRUE, dec = '.', sep = ';',
                   dates.col = 'Dates', ta.col = 'Ta',
                   g0.col = 'G0', keep.cols = FALSE)
{
    #stops if the arguments are not characters or numerics
    stopifnot(is.character(dates.col) || is.numeric(dates.col))
    stopifnot(is.character(ta.col) || is.numeric(ta.col))
    stopifnot(is.character(g0.col) || is.numeric(g0.col))

    #read from file and set it in a data.table
    bd <- fread(file, header = header, fill = fill, dec = dec, sep = sep)

    #check the columns
    if(!(dates.col %in% names(bd))) stop(paste('The column', dates.col, 'is not in the file'))
    if(!(g0.col %in% names(bd))) stop(paste('The column', g0.col, 'is not in the file'))
    if(!(ta.col %in% names(bd))) stop(paste('The column', ta.col, 'is not in the file'))

    #name the dates column by Dates
    Dates <- bd[[dates.col]]
    bd[,(dates.col) := NULL]
    bd[, Dates := as.IDate(Dates, format = format)]

    #name the g0 column by G0
    G0 <- bd[[g0.col]]
    bd[, (g0.col) := NULL]
    bd[, G0 := as.numeric(G0)]

    #name the ta column by Ta
    Ta <- bd[[ta.col]]
    bd[, (ta.col) := NULL]
    bd[, Ta := as.numeric(Ta)]

    names0 <- NULL
    if(all(c('D0', 'B0') %in% names(bd))){
        names0 <- c(names0, 'D0', 'B0')
    }

    names0 <- c(names0, 'Ta')

    if(all(c('TempMin', 'TempMax') %in% names(bd))){
        names0 <- c(names0, 'TempMin', 'TempMax')
    }
    if(keep.cols)
    {
        #keep the rest of the columns but reorder the columns
        setcolorder(bd, c('Dates', 'G0', names0))
    }
    else
    {
        #erase the rest of the columns
        cols <- c('Dates', 'G0', names0)
        bd <- bd[, ..cols]
    }

    setkey(bd, 'Dates')
    result <- new(Class = 'Meteo',
                  latm = lat,
                  data = bd,
                  type = 'bd',
                  source = file)
}

#### file to Meteo (intradaily) ####
readBDi <- function(file, lat,
                    format = "%d/%m/%Y %H:%M:%S",
                    header = TRUE, fill = TRUE, dec = '.',
                    sep = ';', dates.col = 'dates', times.col,
                    ta.col = 'Ta', g0.col = 'G0', keep.cols = FALSE)
{
    #stops if the arguments are not characters or numerics
    stopifnot(is.character(dates.col) || is.numeric(dates.col))
    stopifnot(is.character(ta.col) || is.numeric(ta.col))
    stopifnot(is.character(g0.col) || is.numeric(g0.col))

    #read from file and set it in a data.table
    bd <- fread(file, header = header, fill = fill, dec = dec, sep = sep)

    #check the columns
    if(!(dates.col %in% names(bd))) stop(paste('The column', dates.col, 'is not in the file'))
    if(!(g0.col %in% names(bd))) stop(paste('The column', g0.col, 'is not in the file'))
    if(!(ta.col %in% names(bd))) stop(paste('The column', ta.col, 'is not in the file'))

    if(!missing(times.col)){
        stopifnot(is.character(times.col) || is.numeric(times.col))
        if(!(times.col %in% names(bd))) stop(paste('The column', times.col, 'is not in the file'))

        #name the dates column by Dates
        format <- strsplit(format, ' ')
        dd <- as.IDate(bd[[dates.col]], format = format[[1]][1])
        tt <- as.ITime(bd[[times.col]], format = format[[1]][2])
        bd[,(dates.col) := NULL]
        bd[,(times.col) := NULL]
        bd[, Dates := as.POSIXct(dd, tt, tz = 'UTC')]
    }

    else
    {
        dd <- as.POSIXct(bd[[dates.col]], format = format, tz = 'UTC')
        bd[, (dates.col) := NULL]
        bd[, Dates := dd]
    }

    #name the g0 column by G0
    G0 <- bd[[g0.col]]
    bd[, (g0.col) := NULL]
    bd[, G0 := as.numeric(G0)]

    #name the ta column by Ta
    Ta <- bd[[ta.col]]
    bd[, (ta.col) := NULL]
    bd[, Ta := as.numeric(Ta)]

    names0 <- NULL
    if(all(c('D0', 'B0') %in% names(bd))){
        names0 <- c(names0, 'D0', 'B0')
    }

    names0 <- c(names0, 'Ta')

    if(keep.cols)
    {
        #keep the rest of the columns but reorder the columns
        setcolorder(bd, c('Dates', 'G0', names0))
    }
    else
    {
        #erase the rest of the columns
        cols <- c('Dates', 'G0', names0)
        bd <- bd[, ..cols]
    }

    setkey(bd, 'Dates')
    result <- new(Class = 'Meteo',
                  latm = lat,
                  data = bd,
                  type = 'bdI',
                  source = file)
}


dt2Meteo <- function(file, lat, source = '', type){
    ## Make sure its a data.table
    bd <- data.table(file)

    ## Dates is an as.POSIX element
    bd[, Dates := as.POSIXct(Dates, tz = 'UTC')]

    ## type
    if(missing(type)){
        sample <- median(diff(file$Dates))
        IsDaily <- as.numeric(sample, units = 'days')
        if(is.na(IsDaily)) IsDaily <- ifelse('G0d' %in% names(bd),
                                             1, 0)
        if(IsDaily >= 30) type <- 'prom'
        else{
            type <- ifelse(IsDaily >= 1, 'bd', 'bdI') 
        }

    }
    if(!('Ta' %in% names(bd))){
        if(all(c('Tempmin', 'TempMax') %in% names(bd)))
            bd[, Ta := mean(c(Tempmin, TempMax))]
        else bd[, Ta := 25]
            }

    ## Columns of the data.table
    nms0 <- switch(type,
                   bd = ,
                   prom = {
                       nms0 <- 'G0d'
                       if(all(c('D0d', 'B0d') %in% names(bd))){
                           nms0 <- c(nms0, 'D0d', 'B0d')
                       }
                       nms0 <- c(nms0, 'Ta')
                       if(all(c('TempMin', 'TempMax') %in% names(bd))){
                           nms0 <- c(nms0, 'TempMin', 'TempMax')
                       }
                       nms0
                   },
                   bdI = {
                       nms0 <- 'G0'
                       if(all(c('D0', 'B0') %in% names(bd))){
                           nms0 <- c(nms0, 'D0', 'B0')
                       }
                       if('Ta' %in% names(bd)){
                           nms0 <- c(nms0, 'Ta')
                       }
                       nms0
                   })
    ## Columns order and set key
    setcolorder(bd, c('Dates', nms0))
    setkey(bd, 'Dates')
    ## Result
    result <- new(Class = 'Meteo',
                  latm = lat,
                  data = bd,
                  type = type,
                  source = source)
}

#### Liu and Jordan, Collares-Pereira and Rabl proposals ####
collper <- function(sol, compD)
{
    ind.rep <- cumsum(c(1, as.Date(indexI(sol)) != 0))
    solI <- as.data.tableI(sol, complete = T)
    ws <- solI$ws
    w <- solI$w

    a <- 0.409-0.5016*sin(ws+pi/3)
    b <- 0.6609+0.4767*sin(ws+pi/3)

    rd <- solI[, Bo0/Bo0d]
    rg <- rd * (a + b * cos(w))

    # Daily irradiation components
    G0d <- compD$G0d[ind.rep]
    B0d <- compD$B0d[ind.rep]
    D0d <- compD$D0d[ind.rep]

    # Daily profile
    G0 <- G0d * rg
    D0 <- D0d * rd

    # This method may produce diffuse irradiance higher than
    # global irradiance
    G0 <- pmax(G0, D0, na.rm = TRUE)
    B0 <- G0 - D0

    # Negative values are set to NA
    neg <- (B0 < 0) | (D0 < 0) | (G0 < 0)
    is.na(G0) <- neg
    is.na(B0) <- neg
    is.na(D0) <- neg

    # Daily profiles are scaled to keep daily irradiation values
    day <- truncDay(indexI(sol))
    sample <- sol@sample

    G0dCP <- ave(G0, day, FUN=function(x) P2E(x, sample))
    B0dCP <- ave(B0, day, FUN=function(x) P2E(x, sample))
    D0dCP <- ave(D0, day, FUN=function(x) P2E(x, sample))

    G0 <- G0 * G0d/G0dCP
    B0 <- B0 * B0d/B0dCP
    D0 <- D0 * D0d/D0dCP

    res <- data.table(G0, B0, D0)
    return(res)
}


#### intradaily Meteo to daily Meteo ####
Meteoi2Meteod <- function(G0i)
{
    lat <- G0i@latm
    source <- G0i@source

    dt0 <- getData(G0i)
    dt <- dt0[, lapply(.SD, sum), 
             .SDcols = names(dt0)[!names(dt0) %in% c('Dates', 'Ta')],
             by = .(Dates = as.IDate(Dates))]
    if('Ta' %in% names(dt0)){
        Ta <- dt0[, .(Ta = mean(Ta),
                      TempMin = min(Ta),
                      TempMax = max(Ta)),
                  by = .(Dates = as.IDate(Dates))]
        if(all(Ta$Ta == c(Ta$TempMin, Ta$TempMax))) Ta[, c('TempMin', 'TempMax') := NULL]
        dt <- merge(dt, Ta)
    }
    if('G0' %in% names(dt)){
        names(dt)[names(dt) == 'G0'] <- 'G0d'
    }
    if('D0' %in% names(dt)){
        names(dt)[names(dt) == 'D0'] <- 'D0d'
    }
    if('B0' %in% names(dt)){
        names(dt)[names(dt) == 'B0'] <- 'B0d'
    }
    G0d <- dt2Meteo(dt, lat, source, type = 'bd')
    return(G0d)
}

#### daily Meteo to monthly Meteo ####
Meteod2Meteom <- function(G0d)
{
    lat <- G0d@latm
    source <- G0d@source

    dt <- getData(G0d)
    nms <- names(dt)[-1]
    dt <- dt[, lapply(.SD, mean),
             .SDcols = nms,
             by = .(month(Dates), year(Dates))]
    dt[, Dates := fBTd()]
    dt <- dt[, c('month', 'year') := NULL]

    setcolorder(dt, 'Dates')

    G0m <- dt2Meteo(dt, lat, source, type = 'prom')
    return(G0m)
}

zoo2Meteo <- function(file, lat, source = '')
{
    sample <- median(diff(index(file)))
    IsDaily <- as.numeric(sample, units = 'days')>=1
    type <- ifelse(IsDaily, 'bd', 'bdI')
    result <- new(Class = 'Meteo',
                  latm = lat,
                  data = file,
                  type = type,
                  source = source)
}

siarGET <- function(id, inicio, final, tipo = 'Mensuales', ambito = 'Estacion'){
    if(!(tipo %in% c('Horarios', 'Diarios', 'Semanales', 'Mensuales'))){
        stop('argument \'tipo\' must be: Horarios, Diarios, Semanales or Mensuales')
    }
    if(!(ambito %in% c('CCAA', 'Provincia', 'Estacion'))){
        stop('argument \'ambito\' must be: CCAA, Provincia or Estacion')
    }

    mainURL <- "https://servicio.mapama.gob.es"

    path <- paste('/apisiar/API/v1/Datos', tipo, ambito, sep = '/')

    ## prepare the APIsiar
    req <- request(mainURL) |>
        req_url_path(path) |>
        req_url_query(Id = id,
                      FechaInicial = inicio,
                      FechaFinal = final,
                      ClaveAPI = '_Q8L_niYFBBmBs-vB3UomUqdUYy98FTRX1aYbrZ8n2FXuHYGTV')
    ## execute it
    resp <- req_perform(req)

    ##JSON to R
    respJSON <- resp_body_json(resp, simplifyVector = TRUE)

    if(!is.null(respJSON$MensajeRespuesta)){
        stop(respJSON$MensajeRespuesta)
    }

    res0 <- data.table(respJSON$Datos)

    res <- switch(tipo,
                  Horarios = {
                      res0[, HoraMin := as.ITime(sprintf('%04d', HoraMin),
                                                 format = '%H%M')]
                      res0[, Fecha := as.IDate(Fecha, format = '%Y-%m-%d')]
                      res0[, Fecha := as.IDate(ifelse(HoraMin == as.ITime(0),
                                                      Fecha+1, Fecha))]
                      res0[, Dates := as.POSIXct(HoraMin, Fecha,
                                                 tz = 'Europe/Madrid')]
                      res0 <- res0[, .(Dates,
                                       G0 = Radiacion,
                                       Ta = TempMedia)]
                      return(res0)
                  },
                  Diarios = {
                      res0[, Dates := as.IDate(Fecha)]
                      res0 <- res0[, .(Dates,
                                       G0d = Radiacion * 277.78,
                                       Ta = TempMedia,
                                       TempMin,
                                       TempMax)]
                      return(res0)
                  },
                  Semanales = res0,
                  Mensuales = {
                      promDays<-c(17,14,15,15,15,10,18,18,18,19,18,13)
                      names(res0)[1] <- 'Year'
                      res0[, Dates := as.IDate(paste(Year, Mes,
                                                     promDays[Mes],
                                                     sep = '-'))]
                      res0 <- res0[, .(Dates,
                                       G0d = Radiacion * 277.78,
                                       Ta = TempMedia,
                                       TempMin,
                                       TempMax)]
                  })

    return(res)
}

haversine <- function(lat1, lon1, lat2, lon2) {
    R <- 6371  # Radius of the Earth in kilometers
    dLat <- (lat2 - lat1) * pi / 180
    dLon <- (lon2 - lon1) * pi / 180
    a <- sin(dLat / 2) * sin(dLat / 2) + cos(lat1 * pi / 180) *
        cos(lat2 * pi / 180) * sin(dLon / 2) * sin(dLon / 2)
    c <- 2 * atan2(sqrt(a), sqrt(1 - a))
    d <- R * c
    return(d)
}

readSIAR <- function(Lon = 0, Lat = 0,
                     inicio = paste(year(Sys.Date())-1, '01-01', sep = '-'),
                     final = paste(year(Sys.Date())-1, '12-31', sep = '-'),
                     tipo = 'Mensuales', n_est = 3){
    inicio <- as.Date(inicio)
    final <- as.Date(final)

    n_reg <- switch(tipo,
                    Horarios = {
                        tt <- difftime(final, inicio, units = 'days')
                        tt <- (as.numeric(tt)+1)*48
                        tt <- tt*n_est
                        tt
                    },
                    Diarios = {
                        tt <- difftime(final, inicio, units = 'days')
                        tt <- as.numeric(tt)+1
                        tt <- tt*n_est
                        tt
                    },
                    Semanales = {
                        tt <- difftime(final, inicio, units = 'weeks')
                        tt <- as.numeric(tt)
                        tt <- tt*n_est
                        tt
                    },
                    Mensuales = {
                        tt <- difftime(final, inicio, units = 'weeks')
                        tt <- as.numeric(tt)/4.34524
                        tt <- ceiling(tt)
                        tt <- tt*n_est
                        tt
                    })
    if(n_reg > 100) stop(paste('Number of requested records (', n_reg,
                                ') exceeds the maximum allowed (100)', sep = ''))
    ## Obtain the nearest stations
    siar <- est_SIAR[
        Fecha_Instalacion <= final & (is.na(Fecha_Baja) | Fecha_Baja >= inicio)
    ]

    ## Weigths for the interpolation
    siar[, dist := haversine(Latitud, Longitud, Lat, Lon)]
    siar <- siar[order(dist)][1:n_est]
    siar[, peso := 1/dist]
    siar[, peso := peso/sum(peso)]
    ## Is the given location within the polygon formed by the stations?
    siar <- siar[, .(Estacion, Codigo, dist, peso)]

    ## List for the data.tables of siarGET
    siar_list <- list()
    for(codigo in siar$Codigo){
        siar_list[[codigo]] <- siarGET(id = codigo,
                                       inicio = as.character(inicio),
                                       final = as.character(final),
                                       tipo = tipo)
        siar_list[[codigo]]$peso <- siar[Codigo == codigo, peso]
    }

    ## Bind the data.tables
    s_comb <- rbindlist(siar_list, use.names = TRUE, fill = TRUE)

    nms <- names(s_comb)
    nms <- nms[-c(1, length(nms))]

    ## Interpole
    res <- s_comb[, lapply(.SD * peso, sum, na.rm = TRUE),
                  .SDcols = nms,
                  by = Dates]

    ## Source
    mainURL <- "https://servicio.mapama.gob.es"
    Estaciones <- siar[, paste(Estacion, '(', Codigo, ')', sep = '')]
    Estaciones <- paste(Estaciones, collapse = ', ')
    source <- paste(mainURL, '\n  -Estaciones:', Estaciones, sep = ' ')

    res <- switch(tipo,
                  Horarios = {dt2Meteo(res, lat = Lat, source = mainURL, type = 'bdI')},
                  Diarios = {dt2Meteo(res, lat = Lat, source = mainURL, type = 'bd')},
                  Semanales = {res},
                  Mensuales = {dt2Meteo(res, lat = Lat, source = source, type = 'prom')})
    return(res)
}
\end{lstlisting}

\section{Clases}
\label{sec:org028b69f}
\subsection{Sol}
\label{sec:orge7c9d34}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setClass(
         Class='Sol', ##Solar angles
         slots = c(
             lat='numeric',#latitud in degrees, >0 if North
             solD='data.table',#daily angles
             solI='data.table',#intradaily angles
             sample='character',#sample of time
             method='character'#method used for geometry calculations
         ),
    validity=function(object) {return(TRUE)}
)
\end{lstlisting}
\subsection{Meteo}
\label{sec:orgd687749}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setClass(
    Class = 'Meteo', ##radiation and temperature data
    slots = c(
        latm='numeric',#latitud in degrees, >0 if North
        data='data.table',#data, incluying G (Wh/m2) and Ta (ºC)
        type='character',#choose between 'prom', 'bd' and 'bdI'
        source='character'#origin of the data
    ),
    validity=function(object) {return(TRUE)}
)
\end{lstlisting}
\subsection{G0}
\label{sec:org1e3cdc7}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setClass(
    Class = 'G0',
    slots = c(
        G0D = 'data.table',  #result of fCompD
        G0dm = 'data.table', #monthly means
        G0y = 'data.table',  #yearly values
        G0I = 'data.table',  #result of fCompI
        Ta = 'data.table'    #Ambient temperature
    ),
    contains = c('Sol', 'Meteo'),
    validity = function(object) {return(TRUE)}
)

\end{lstlisting}
\subsection{Gef}
\label{sec:org6373691}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setClass(
         Class='Gef',
         slots = c(
           GefD='data.table',  #daily values
           Gefdm='data.table', #monthly means
           Gefy='data.table',  #yearly values
           GefI='data.table',  #result of fInclin
           Theta='data.table', #result of fTheta
           iS='numeric',       #dirt index
           alb='numeric',      #albedo
           modeTrk='character',   #tracking mode
           modeShd='character',   #shadow mode
           angGen='list',         #includes alpha, beta and betaLim
           struct='list',         #structure dimensions
           distances='data.frame' #distances between structures
           ),
         contains='G0',
         validity=function(object) {return(TRUE)}
)
\end{lstlisting}
\subsection{ProdGCPV}
\label{sec:org5849edd}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setClass(
         Class='ProdGCPV',
         slots = c(
           prodD='data.table',  #daily values
           prodDm='data.table', #monthly means
           prody='data.table',  #yearly values
           prodI='data.table',  #results of fProd
           module='list',       #module characteristics
           generator='list',    #generator characteristics
           inverter='list',     #inverter characteristics
           effSys='list'        #efficiency values of the system
           ),
         contains='Gef',
         validity=function(object) {return(TRUE)}
)
\end{lstlisting}
\subsection{ProdPVPS}
\label{sec:org47582fb}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setClass(
         Class='ProdPVPS',
         slots = c(
           prodD='data.table',  #daily values
           prodDm='data.table', #monthly means
           prody='data.table',  #yearly values
           prodI='data.table',  #results of fPump
           Pg='numeric',        #generator power
           H='numeric',         #manometric head
           pump='list',         #parameters of the pump
           converter='list',    #inverter characteristics
           effSys='list'        #efficiency values of the system
           ),
         contains='Gef',
         validity=function(object) {return(TRUE)}
)
\end{lstlisting}
\subsection{Shade}
\label{sec:org6ee6c51}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setClass(
         Class='Shade',
         slots = c(
           FS='numeric',  #shadows factor values
           GRR='numeric', #Ground Requirement Ratio
           Yf='numeric',  #final productivity
           FS.loess='loess', #local fitting of FS with loess
           Yf.loess='loess', #local fitting of Yf with loess
           modeShd='character', #mode of shadow
           struct='list',       #dimensions of the structures
           distances='data.frame', #distances between structures
           res='numeric'           #difference between the different steps of the calculations
           ),
         contains='ProdGCPV',##Resultado de prodGCPV sin sombras (Prod0)
         validity=function(object) {return(TRUE)}
)
\end{lstlisting}
\section{Funciones}
\label{sec:org05f1a9d}
\subsection{corrFdKt}
\label{sec:org0f21a17}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
#### monthly Kt ####
Ktm <- function(sol, G0dm){
    solf <- sol@solD[, .(Dates, Bo0d)]
    solf[, c('month', 'year') := .(month(Dates), year(Dates))]
    solf[,Bo0m := mean(Bo0d), by = .(month, year)]
    G0df <- G0dm@data[, .(Dates, G0d)]
    G0df[, c('month', 'year') := .(month(Dates), year(Dates))]
    G0df[, G0d := mean(G0d), by = .(month, year)]
    Ktm <- G0df$G0d/solf$Bo0m
    return(Ktm)
}

#### daily Kt ####
Ktd <- function(sol, G0d){
    Bo0d <- sol@solD$Bo0d
    G0d <- getG0(G0d)
    Ktd <- G0d/Bo0d
    return(Ktd)
}

### intradaily
Kti <- function(sol, G0i){
    Bo0 <- sol@solI$Bo0
    G0i <- getG0(G0i)
    Kti <- G0i/Bo0
    return(Kti)
}


#### monthly correlations ####

### Page ###
FdKtPage <- function(sol, G0dm){
    Kt <- Ktm(sol, G0dm)
    Fd=1-1.13*Kt
    return(data.table(Fd, Kt))
}

### Liu and Jordan ###
FdKtLJ <- function(sol, G0dm){
    Kt <- Ktm(sol, G0dm)
    Fd=(Kt<0.3)*0.595774 +
        (Kt>=0.3 & Kt<=0.7)*(1.39-4.027*Kt+5.531*Kt^2-3.108*Kt^3)+
        (Kt>0.7)*0.215246
    return(data.table(Fd, Kt))
}


#### daily correlations ####

### Collares-Pereira and Rabl
FdKtCPR <- function(sol, G0d){
    Kt <- Ktd(sol, G0d)
    Fd=(0.99*(Kt<=0.17))+(Kt>0.17 & Kt<0.8)*
        (1.188-2.272*Kt+9.473*Kt^2-21.856*Kt^3+14.648*Kt^4)+
        (Kt>=0.8)*0.2426688      
    return(data.table(Fd, Kt))
}

### Erbs, Klein and Duffie ###
FdKtEKDd <- function(sol, G0d){
    ws <- sol@solD$ws
    Kt <- Ktd(sol, G0d)

    WS1=(abs(ws)<1.4208)
    Fd=WS1*((Kt<0.715)*(1-0.2727*Kt+2.4495*Kt^2-11.9514*Kt^3+9.3879*Kt^4)+
            (Kt>=0.715)*(0.143))+
        !WS1*((Kt<0.722)*(1+0.2832*Kt-2.5557*Kt^2+0.8448*Kt^3)+
              (Kt>=0.722)*(0.175))
  return(data.table(Fd, Kt))
}

### CLIMED1 ###
FdKtCLIMEDd <- function(sol, G0d){
    Kt <- Ktd(sol, G0d)
    Fd=(Kt<=0.13)*(0.952)+
    (Kt>0.13 & Kt<=0.8)*(0.868+1.335*Kt-5.782*Kt^2+3.721*Kt^3)+
      (Kt>0.8)*0.141
  return(data.table(Fd, Kt))
}

#### intradaily correlations ####

### intradaily EKD ###
FdKtEKDh <- function(sol, G0i){
    Kt <- Kti(sol, G0i)
    Fd=(Kt<=0.22)*(1-0.09*Kt)+
    (Kt>0.22 & Kt<=0.8)*(0.9511-0.1604*Kt+4.388*Kt^2-16.638*Kt^3+12.336*Kt^4)+
      (Kt>0.8)*0.165
  return(data.table(Fd, Kt))
}

### intradaily CLIMED
FdKtCLIMEDh <- function(sol, G0i){
    Kt <- Kti(sol, G0i)
    Fd=(Kt<=0.21)*(0.995-0.081*Kt)+
        (Kt>0.21 & Kt<=0.76)*(0.724+2.738*Kt-8.32*Kt^2+4.967*Kt^3)+
        (Kt>0.76)*0.180
    return(data.table(Fd, Kt))
}

### intradaily Boland, Ridley and Lauret ###
FdKtBRL <- function(sol, G0i){
    Kt <- Kti(sol, G0i)
    sample <- sol@sample

    solI <- as.data.tableI(sol, complete = TRUE)
    w <- solI$w
    night <- solI$night
    AlS <- solI$AlS

    G0d <- Meteoi2Meteod(G0i)
    ktd <- Ktd(sol, G0d)

    ##persistence    
    pers <- persistence(sol, ktd)

    ##indexRep for ktd and pers
    ind.rep <- cumsum(c(1, as.Date(indexI(sol)) != 0))
    ktd <- ktd[ind.rep]
    pers <- pers[ind.rep]

    ##fd calculation
    Fd=(1+exp(-5.38+6.63*Kt+0.006*r2h(w)-0.007*r2d(AlS)+1.75*ktd+1.31*pers))^(-1)

    return(data.table(Fd, Kt))
}

persistence <- function(sol, Ktd){
    kt <- data.table(indexD(sol), Ktd)
    ktNA <- na.omit(kt)
    iDay <- truncDay(ktNA[[1]])

    x <- rle(as.numeric(iDay))$lengths
    xLast <- cumsum(x)

    lag1 <- shift(ktNA$Ktd, -1, fill = NA)
    for (i in xLast){
        if ((i-1) != 0){lag1[i] <- ktNA$Ktd[i-1]}
    }

    lag2 <- shift(ktNA$Ktd, 1, fill = NA)
    for (i in xLast){
        if ((i+1) <= length(ktNA$Ktd)){lag2[i] <- ktNA$Ktd[i+1]}
    }
    pers <- data.table(lag1, lag2)
    pers[, mean := 1/2 * (lag1+lag2)]
    pers[, mean]
}
\end{lstlisting}
\subsection{fBTd}
\label{sec:org1f85ce7}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fBTd<-function(mode='prom',
               year= as.POSIXlt(Sys.Date())$year+1900,
               start=paste('01-01-',year,sep=''),
               end=paste('31-12-',year,sep=''), 
               format='%d-%m-%Y'){
    promDays<-c(17,14,15,15,15,10,18,18,18,19,18,13)
    BTd=switch(mode,
               serie={
                   start.<-as.POSIXct(start, format=format, tz='UTC')
                   end.<-as.POSIXct(end, format=format, tz='UTC')
                   res<-seq(start., end., by="1 day")
               },
               prom=as.POSIXct(paste(year, 1:12, promDays, sep='-'), tz='UTC')
               )
    BTd
}
\end{lstlisting}
\subsection{fBTi}
\label{sec:org2049ff8}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
intervalo <- function(day, sample){
    intervalo <- seq.POSIXt(from = as.POSIXct(paste(day, '00:00:00'), tz = 'UTC'),
                      to = as.POSIXct(paste(day, '23:59:59'), tz = 'UTC'),
                      by = sample)
    return(intervalo)
}

fBTi <- function(d, sample = 'hour'){
    BTi <- lapply(d, intervalo, sample)
    BTi <- do.call(c, BTi)
    return(BTi)
}
\end{lstlisting}
\subsection{fCompD}
\label{sec:org5704e05}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fCompD <- function(sol, G0d, corr = 'CPR', f)
{
    if(!(corr %in% c('CPR', 'Page', 'LJ', 'EKDd', 'CLIMEDd', 'user', 'none'))){
        warning('Wrong descriptor of correlation Fd-Ktd. Set CPR.')
        corr <- 'CPR'
    }
    if(class(sol)[1] != 'Sol'){
        sol <- sol[, calcSol(lat = unique(lat), BTi = Dates)]
    }
    if(class(G0d)[1] != 'Meteo'){
        dt <- copy(data.table(G0d))
        if(!('Dates' %in% names(dt))){
            dt[, Dates := indexD(sol)]
            setcolorder(dt, 'Dates')
            setkey(dt, 'Dates')
        }
        if('lat' %in% names(dt)){
            latg <- unique(dt$lat)
            dt[, lat := NULL]
        }else{latg <- getLat(sol)}
        G0d <- dt2Meteo(dt, latg)
    }  

    stopifnot(indexD(sol) == indexD(G0d))
    Bo0d <- sol@solD$Bo0d
    G0 <- getData(G0d)$G0

    is.na(G0) <- (G0>Bo0d)

    ### the Direct and Difuse data is not given
    if(corr != 'none'){
        Fd <- switch(corr,
                     CPR = FdKtCPR(sol, G0d),
                     Page = FdKtPage(sol, G0d),
                     LJ = FdKtLJ(sol, G0d),
                     CLIMEDd = FdKtCLIMEDd(sol, G0d),
                     user = f(sol, G0d))
        Kt <- Fd$Kt
        Fd <- Fd$Fd
        D0d <- Fd * G0
        B0d <- G0 - D0d
    }
    ### the Direct and Difuse data is given
    else {
        G0 <- getData(G0d)$G0
        D0d <- getData(G0d)[['D0']]
        B0d <- getData(G0d)[['B0']]
        Fd <- D0d/G0
        Kt <- G0/Bo0d
    }

    result <- data.table(Dates = indexD(sol), Fd, Kt, G0d = G0, D0d, B0d)
    setkey(result, 'Dates')
    result
}
\end{lstlisting}
\subsection{fCompI}
\label{sec:org99bd199}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fCompI <- function(sol, compD, G0I,
                   corr = 'EKDh', f,
                   filterG0 = TRUE){
    if(!(corr %in% c('EKDh', 'CLIMEDh', 'BRL', 'user', 'none'))){
        warning('Wrong descriptor of correlation Fd-Ktd. Set EKDh.')
        corr <- 'EKDh'
    }

    if(class(sol)[1] != 'Sol'){
        sol <- sol[, calcSol(lat = unique(lat), BTi = Dates)]
    }

    lat <- sol@lat
    sample <- sol@sample
    night <- sol@solI$night
    Bo0 <- sol@solI$Bo0
    Dates <- indexI(sol)

    ## If instantaneous values are not provided, compD is used instead.
    if (missing(G0I)) { 

        G0I <- collper(sol, compD)
        G0 <- G0I$G0
        B0 <- G0I$B0
        D0 <- G0I$D0

        Fd <- D0/G0
        Kt <- G0/Bo0

    } else { ## Use instantaneous values if provided through G0I

        if(class(G0I)[1] != 'Meteo'){
            dt <- copy(G0I)
            if(!('Dates' %in% names(G0I))){
                dt[, Dates := indexI(sol)]
                setcolorder(dt, 'Dates')
                setkey(dt, 'Dates')
            }
            if('lat' %in% names(G0I)){latg <- unique(G0I$lat)}
            else{latg <- lat}
            G0I <- dt2Meteo(dt, latg)
        }

        if (corr!='none'){
            G0 <- getG0(G0I)
            ## Filter values: surface irradiation must be lower than
            ## extraterrestial; 
            if (filterG0) {is.na(G0) <- (G0 > Bo0)}

            ## Fd-Kt correlation
            Fd <- switch(corr,
                         EKDh = FdKtEKDh(sol, G0I),
                         CLIMEDh = FdKtCLIMEDh(sol, G0I),
                         BRL = FdKtBRL(sol, G0I), 
                         user = f(sol, G0I))

            Kt <- Fd$Kt
            Fd <- Fd$Fd
            D0 <- Fd * G0
            B0 <- G0 - D0

        } else { 
            G0 <- getG0(G0I)
            D0 <- getData(G0I)[['D0']]
            B0 <- getData(G0I)[['B0']]
            ## Filter values: surface irradiation must be lower than
            ## extraterrestial; 
            if (isTRUE(filterG0)) is.na(G0) <- is.na(D0) <- is.na(B0) <- (G0 > Bo0)

            Fd <- D0/G0
            Kt <- G0/Bo0
        }
    }
    ## Values outside sunrise-sunset are set to zero
    G0[night] <- D0[night] <- B0[night] <- Kt[night] <- Fd[night] <- 0

    result <- data.table(Dates, Fd, Kt, G0, D0, B0)
    setkey(result, 'Dates')
    result
}
\end{lstlisting}
\subsection{fInclin}
\label{sec:org137365b}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fInclin <- function(compI, angGen, iS = 2, alb = 0.2, horizBright = TRUE, HCPV = FALSE){
    ##compI es class='G0'

    ##Arguments
    stopifnot(iS %in% 1:4)
    Beta <- angGen$Beta
    Alfa <- angGen$Alfa
    cosTheta <- angGen$cosTheta

    comp <- as.data.tableI(compI, complete=TRUE)
    night <- comp$night
    B0 <- comp$B0
    Bo0 <- comp$Bo0
    D0 <- comp$D0
    G0 <- comp$G0
    cosThzS <- comp$cosThzS
    is.na(cosThzS) <- night

    ##N.Martin method for dirt and non-perpendicular incidence
    Suc <- rbind(c(1, 0.17, -0.069),
                 c(0.98,.2,-0.054),
                 c(0.97,0.21,-0.049),
                 c(0.92,0.27,-0.023))
    FTb <- (exp(-cosTheta/Suc[iS,2]) - exp(-1/Suc[iS,2]))/(1 - exp(-1/Suc[iS,2]))
    FTd <- exp(-1/Suc[iS,2] * (4/(3*pi) * (sin(Beta) + (pi - Beta - sin(Beta))/(1 + cos(Beta))) +
                               Suc[iS,3] * (sin(Beta) + (pi - Beta - sin(Beta))/(1 + cos(Beta)))^2))
    FTr <- exp(-1/Suc[iS,2] * (4/(3*pi) * (sin(Beta) + (Beta - sin(Beta))/(1 - cos(Beta))) +
                               Suc[iS,3] * (sin(Beta) + (Beta - sin(Beta))/(1 - cos(Beta)))^2))

    ##Hay and Davies method for diffuse treatment
    B <- B0 * cosTheta/cosThzS * (cosThzS>0.007) #The factor cosThzS>0.007 is needed to eliminate erroneous results near dawn
    k1 <- B0/(Bo0)
    Di <- D0 * (1-k1) * (1+cos(Beta))/2
    if (horizBright) Di <- Di * (1+sqrt(B0/G0) * sin(Beta/2)^3)
    Dc <- D0 * k1 * cosTheta/cosThzS * (cosThzS>0.007)
    R <- alb * G0 * (1-cos(Beta))/2
    D <- (Di + Dc)
    ##Extraterrestrial irradiance on the inclined plane
    Bo <- Bo0 * cosTheta/cosThzS * (cosThzS>0.007) 
    ##Normal direct irradiance (DNI)
    Bn <- B0/cosThzS
    ##Sum of components
    G <- B + D + R
    Ref <- R * Suc[iS,1] * (1-FTr) * (!HCPV)
    Ref[is.nan(FTr)] <- 0 #When cos(Beta)=1, FTr=NaN. Cancel Ref.
    Dief <- Di * Suc[iS,1] * (1 - FTd) * (!HCPV)
    Dcef <- Dc * Suc[iS,1] * (1 - FTb) * (!HCPV)
    Def <- Dief + Dcef
    Bef <- B * Suc[iS,1] * (1 - FTb)
    Gef <- Bef + Def + Ref

    result <- data.table(Bo, Bn,
                         G, D, Di, Dc, B, R,
                         FTb, FTd, FTr,
                         Dief, Dcef, Gef, Def, Bef, Ref) 

    ## Use 0 instead of NA for irradiance values
    result[night] <- 0
    result[, Dates := indexI(compI)]
    result[, .SD, by = Dates]
    setcolorder(result, c('Dates', names(result)[-length(result)]))
    result
}
\end{lstlisting}
\subsection{fProd}
\label{sec:orgbb6cf48}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
## voc, isc, vmpp, impp : *cell* values
## Voc, Isc, Vmpp, Impp: *module/generator* values

## Compute Current - Voltage characteristic of a solar *cell* with Gef
## and Ta
iv <- function(vocn, iscn, vmn, imn,
               TONC, CoefVT = 2.3e-3,
               Ta, Gef,
               vmin = NULL, vmax = NULL)
{
    ##Cell Constants
    Gstc <- 1000
    Ct <- (TONC - 20) / 800
    Vtn <- 0.025 * (273 + 25) / 300
    m <- 1.3

    ##Cell temperature
    Tc <- Ta + Ct * Gef
    Vt <- 0.025 * (Tc + 273)/300

    ## Series resistance
    Rs <- (vocn - vmn + m * Vtn * log(1 - imn/iscn)) / imn

    ## Voc and Isc at ambient conditions
    voc <- vocn - CoefVT * (Tc - 25)
    isc <- iscn * Gef/Gstc

    ## Ruiz method for computing voltage and current characteristic of a *cell*
    rs <- Rs * isc/voc
    koc <- voc/(m * Vt)

    ## Maximum Power Point
    Dm0 <- (koc - 1)/(koc - log(koc))
    Dm <- Dm0 + 2 * rs * Dm0^2

    impp <- isc * (1 - Dm/koc)
    vmpp <- voc * (1 - log(koc/Dm)/koc - rs * (1 - Dm/koc))

    vdc <- vmpp
    idc <- impp

    ## When the MPP is below/above the inverter voltage limits, it
    ## sets the voltage point at the corresponding limit.


    ## Auxiliary functions for computing the current at a defined
    ## voltage.
    ilimit <- function(v, koc, rs) 
    {
        if (is.na(koc)) 
            result <- NA
        else
        {
            ## The IV characteristic is an implicit equation. The starting
            ## point is the voltage of the cell (imposed by the inverter
            ## limit). 

            izero <- function(i , v, koc, rs)
            {
                vp <- v + i * rs
                Is <- 1/(1 - exp(-koc * (1 - rs)))
                result <- i - (1 - Is * (exp(-koc * (1 - vp)) - exp(-koc * (1 - rs))))
            }

            result <- uniroot(f = izero,
                              interval = c(0,1),
                              v = v,
                              koc = koc,
                              rs = rs)$root
        }
        result
    }
    ## Inverter minimum voltage
    if (!is.null(vmin))
    {
        if (any(vmpp < vmin, na.rm = TRUE))
        {
            indMIN <- which(vmpp < vmin)
            imin <- sapply(indMIN, function(i)
            {
                vocMIN <- voc[i]
                kocMIN <- koc[i]
                rsMIN <- rs[i]
                vmin <- vmin/vocMIN
                ##v debe estar entre 0 y 1
                vmin[vmin < 0] <- 0
                vmin[vmin > 1] <- 1
                ilimit(vmin, kocMIN, rsMIN)
            })
            iscMIN <- isc[indMIN]
            idc[indMIN] <- imin * iscMIN
            vdc[indMIN] <- vmin
            warning('Minimum MPP voltage of the inverter has been reached')}
    }

    if (!is.null(vmax))
    {
        if (any(vmpp > vmax, na.rm = TRUE))
        {
            indMAX <- which(vmpp > vmax)
            imax <- sapply(indMAX, function(i)
            {
                vocMAX <- voc[i]
                kocMAX <- koc[i]
                rsMAX <- rs[i]
                vmax <- vmax / vocMAX
                ##v debe estar entre 0 y 1
                vmax[vmax < 0] <- 0
                vmax[vmax > 1] <- 1
                ilimit(vmax, kocMAX, rsMAX)
            })
            iscMAX <- isc[indMAX]
            idc[indMAX] <- imax * iscMAX
            vdc[indMAX] <- vmax
            warning('Maximum MPP voltage of the inverter has been reached')
        }
    }
    data.table(Ta, Tc, Gef, voc, isc, vmpp, impp, vdc, idc)
}

fProd <- function(inclin, 
                  module=list(), 
                  generator=list(), 
                  inverter=list(),
                  effSys=list()
                  )
{

    stopifnot(is.list(module),
              is.list(generator),
              is.list(inverter),
              is.list(effSys)
              )
    ## Extract data from objects
    if (class(inclin)[1]=='Gef') {
        indInclin <- indexI(inclin)
        gefI <- as.data.tableI(inclin, complete = TRUE)
        Gef <- gefI$Gef
        Ta <- gefI$Ta
    } else {
        Gef <- inclin$Gef
        Ta <- inclin$Ta
    }

    ## Module, generator, and inverter parameters
    module.default <- list(Vocn = 57.6,
                           Iscn = 4.7,
                           Vmn = 46.08,
                           Imn = 4.35,
                           Ncs = 96,
                           Ncp = 1,
                           CoefVT = 0.0023,
                           TONC = 47)
    module <- modifyList(module.default, module)
    ## Make these parameters visible because they will be used often.
    Ncs <- module$Ncs
    Ncp <- module$Ncp

    generator.default <- list(Nms = 12,
                              Nmp = 11)
    generator <- modifyList(generator.default, generator)
    generator$Pg <- (module$Vmn * generator$Nms) *
        (module$Imn * generator$Nmp)
    Nms <- generator$Nms
    Nmp <- generator$Nmp

    inverter.default <- list(Ki = c(0.01,0.025,0.05),
                             Pinv = 25000,
                             Vmin = 420,
                             Vmax = 750,
                             Gumb = 20)
    inverter <- modifyList(inverter.default, inverter)
    Pinv <- inverter$Pinv

    effSys.default <- list(ModQual = 3,
                           ModDisp = 2,
                           OhmDC = 1.5,
                           OhmAC = 1.5,
                           MPP = 1,
                           TrafoMT = 1,
                           Disp = 0.5)
    effSys <- modifyList(effSys.default, effSys)

    ## Solar Cell i-v
    vocn <- with(module, Vocn / Ncs)
    iscn <- with(module, Iscn/ Ncp)
    vmn <- with(module, Vmn / Ncs)
    imn <- with(module, Imn / Ncp)
    vmin <- with(inverter, Vmin / (Ncs * Nms))
    vmax <- with(inverter, Vmax / (Ncs * Nms))

    cell <- iv(vocn, iscn,
               vmn, imn,
               module$TONC, module$CoefVT,
               Ta, Gef,
               vmin, vmax)

    ## Generator voltage and current
    Idc <- Nmp * Ncp * cell$idc
    Isc <- Nmp * Ncp * cell$isc
    Impp <- Nmp * Ncp * cell$impp
    Vdc <- Nms * Ncs * cell$vdc
    Voc <- Nms * Ncs * cell$voc
    Vmpp <- Nms * Ncs * cell$vmpp

    ##DC power (normalization with nominal power of inverter)
    ##including losses
    PdcN <- with(effSys, (Idc * Vdc) / Pinv *
                         (1 - ModQual / 100) *
                         (1 - ModDisp / 100) *
                         (1 - MPP / 100) *
                         (1 - OhmDC / 100)
                 ) 

    ##Normalized AC power to the inverter
    Ki <- inverter$Ki
    if (is.matrix(Ki)) { #Ki is a matrix of nine coefficients-->dependence with tension
        VP <- cbind(Vdc, PdcN)
        PacN <- apply(VP, 1, solvePac, Ki)
    } else { #Ki is a vector of three coefficients-->without dependence on voltage
        A <- Ki[3]
        B <- Ki[2] + 1
        C <- Ki[1] - (PdcN)
        PacN <- (-B + sqrt(B^2 - 4 * A * C))/(2 * A)
    }
    EffI <- PacN / PdcN
    pacNeg <- PacN <= 0
    PacN[pacNeg] <- PdcN[pacNeg] <- EffI[pacNeg] <- 0


    ##AC and DC power without normalization
    Pac <- with(effSys, PacN * Pinv *
                        (Gef > inverter$Gumb) *
                        (1 - OhmAC / 100) *
                        (1 - TrafoMT / 100) *
                        (1 - Disp / 100))
    Pdc <- PdcN * Pinv * (Pac > 0)


    ## Result
    resProd <- data.table(Tc = cell$Tc,
                         Voc, Isc,
                         Vmpp, Impp,
                         Vdc, Idc,
                         Pac, Pdc,
                         EffI)
    if (class(inclin)[1] %in% 'Gef'){
        result <- resProd[, .SD,
                          by=.(Dates = indInclin)]
        attr(result, 'generator') <- generator
        attr(result, 'module') <- module
        attr(result, 'inverter') <- inverter
        attr(result, 'effSys') <- effSys
        return(result)
    } else {
        result <- cbind(inclin, resProd)
        return(result)
    }
}
\end{lstlisting}
\subsection{fPump}
\label{sec:org0bd1295}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fPump <- function(pump, H){

    w1=3000 ##synchronous rpm frequency
    wm=2870 ##rpm frequency with slip when applying voltage at 50 Hz
    s=(w1-wm)/w1
    fen=50 ##Nominal electrical frequency
    fmin=sqrt(H/pump$a)
    fmax=with(pump, (-b*Qmax+sqrt(b^2*Qmax^2-4*a*(c*Qmax^2-H)))/(2*a))
    ##fb is rotation frequency (Hz) of the pump,  
    ##fe is the electrical frequency applied to the motor
    ##which makes it rotate at a frequency fb (and therefore also the pump).
    fb=seq(fmin,min(60,fmax),length=1000) #The maximum frequency is 60
    fe=fb/(1-s)

###Flow
    Q=with(pump, (-b*fb-sqrt(b^2*fb^2-4*c*(a*fb^2-H)))/(2*c))
    Qmin=0.1*pump$Qn*fb/50
    Q=Q+(Qmin-Q)*(Q<Qmin)

###Hydraulic power
    Ph=2.725*Q*H

###Mechanical power
    Q50=50*Q/fb
    H50=H*(50/fb)^2
    etab=with(pump, j*Q50^2+k*Q50+l)
    Pb50=2.725*H50*Q50/etab
    Pb=Pb50*(fb/50)^3

###Electrical power
    Pbc=Pb*50/fe
    etam=with(pump, g*(Pbc/Pmn)^2+h*(Pbc/Pmn)+i)
    Pmc=Pbc/etam
    Pm=Pmc*fe/50
    Pac=Pm
    ##Pdc=Pm/(etac*(1-cab))

###I build functions for flow, frequency and powers
###to adjust the AC power.
    fQ<-splinefun(Pac,Q)
    fFreq<-splinefun(Pac,fe)
    fPb<-splinefun(Pac,Pb)
    fPh<-splinefun(Pac,Ph)
    lim=c(min(Pac),max(Pac))
    ##lim marks the operating range of the pump
    result<-list(lim = lim,
                 fQ = fQ,
                 fPb = fPb,
                 fPh = fPh,
                 fFreq = fFreq)
}
\end{lstlisting}
\subsection{fSolD}
\label{sec:org8553773}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fSolD <- function(lat, BTd, method = 'michalsky'){
    if (abs(lat) > 90){
        lat <- sign(lat) * 90
        warning(paste('Latitude outside acceptable values. Set to', lat))
    }
    sun <- data.table(Dates = unique(as.IDate(BTd)),
                      lat = lat)

    #### solarAngles ####

    ##Declination
    sun[, decl := declination(Dates, method = method)]
    ##Eccentricity
    sun[, eo := eccentricity(Dates, method = method)]
    ##Equation of time
    sun[, EoT := eot(Dates)]
    ##Solar time
    sun[, ws := sunrise(Dates, lat, method = method,
                        decl = decl)]
    ##Extraterrestrial irradiance
    sun[, Bo0d := bo0d(Dates, lat, method = method,
                       decl = decl,
                       eo = eo,
                       ws = ws
                       )]
    setkey(sun, Dates)
    return(sun)
}
\end{lstlisting}
\subsection{fSolI}
\label{sec:orga94b46a}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fSolI <- function(solD, sample = 'hour', BTi,
                  EoT = TRUE, keep.night = TRUE, method = 'michalsky')
{
    #Solar constant
    Bo <- 1367

    if(missing(BTi)){
        d <- solD$Dates
        BTi <- fBTi(d, sample)
    }
    sun <- data.table(Dates = as.IDate(BTi),
                      Times = as.ITime(BTi))
    sun <- merge(solD, sun, by = 'Dates')
    sun[, eqtime := EoT]
    sun[, EoT := NULL]

    #sun hour angle
    sun[, w := sunHour(Dates, BTi, EoT = EoT, method = method, eqtime = eqtime)]

    #classify night elements
    sun[, night := abs(w) >= abs(ws)]

    #zenith angle
    sun[, cosThzS := zenith(Dates, lat, BTi,
                            method = method,
                            decl = decl,
                            w = w
                            )]

    #solar altitude angle
    sun[, AlS := asin(cosThzS)]

    #azimuth
    sun[, AzS := azimuth(Dates, lat, BTi, sample,
                         method = method,
                         decl = decl, 
                         w = w,
                         cosThzS = cosThzS)]

    #Extraterrestrial irradiance
    sun[, Bo0 := Bo * eo * cosThzS]

    #When it is night there is no irradiance
    sun[night == TRUE, Bo0 := 0]

    #Erase columns that are in solD
    sun[, decl := NULL]
    sun[, eo := NULL]
    sun[, eqtime := NULL]
    sun[, ws := NULL]
    sun[, Bo0d := NULL]

    #Column Dates with Times
    sun[, Dates := as.POSIXct(Dates, Times, tz = 'UTC')]
    sun[, Times := NULL]

    #keep night
    if(!keep.night){
        sun <- sun[night == FALSE]
    }

    return(sun)
}
\end{lstlisting}
\subsection{fSombra}
\label{sec:orgbfbdde0}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fSombra<-function(angGen, distances, struct, modeTrk='fixed',prom=TRUE){

    stopifnot(modeTrk %in% c('two','horiz','fixed'))
    res=switch(modeTrk, 
               two={fSombra6(angGen, distances, struct, prom)},
               horiz={fSombraHoriz(angGen, distances, struct)},
               fixed= {fSombraEst(angGen, distances, struct)}
               )
    return(res)
}
\end{lstlisting}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fSombra2X<-function(angGen,distances,struct)
{
    stopifnot(is.list(struct),is.data.frame(distances))
    ##I prepare starting data	
    P=with(struct,distances/W)
    b=with(struct,L/W)
    AzS=angGen$AzS
    Beta=angGen$Beta
    AlS=angGen$AlS

    d1=abs(P$Lew*cos(AzS)-P$Lns*sin(AzS))
    d2=abs(P$Lew*sin(AzS)+P$Lns*cos(AzS))
    FC=sin(AlS)/sin(Beta+AlS)
    s=b*cos(Beta)+(b*sin(Beta)+P$H)/tan(AlS)
    FS1=1-d1
    FS2=s-d2
    SombraCond=(FS1>0)*(FS2>0)*(P$Lew*AzS>=0)
    SombraCond[is.na(SombraCond)]<-FALSE #NAs are of no use to me in a logical vector. I replace them with FALSE
    ## Result
    FS=SombraCond*(FS1*FS2*FC)/b
    FS[FS>1]<-1
    return(FS)
}	
\end{lstlisting}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fSombra6<-function(angGen, distances, struct, prom=TRUE)
{
    stopifnot(is.list(struct),
              is.data.frame(distances))
    ##distances only has three distances, so I generate a grid
    if (dim(distances)[1]==1){ 
        Red <- distances[, .(Lew = c(-Lew, 0, Lew, -Lew, Lew),
                             Lns = c(Lns, Lns, Lns, 0, 0),
                             H=H)]
    } else { #distances is an array, so there is no need to generate the grid
        Red<-distances[1:5,]} #I only need the first 5 rows...necessary in case a wrong data.frame is delivered

    ## I calculate the shadow due to each of the 5 followers
    SombraGrupo<-matrix(ncol=5,nrow=dim(angGen)[1]) ###VECTORIZE
    for (i in 1:5) {SombraGrupo[,i]<-fSombra2X(angGen,Red[i,],struct)}
    ##To calculate the Average Shadow, I need the number of followers in each position (distrib)
    distrib=with(struct,c(1,Ncol-2,1,Nrow-1,(Ncol-2)*(Nrow-1),Nrow-1)) 
    vProm=c(sum(distrib[c(5,6)]),
            sum(distrib[c(4,5,6)]),
            sum(distrib[c(4,5)]),
            sum(distrib[c(2,3,5,6)]),
            sum(distrib[c(1,2,4,5)]))
    Nseg=sum(distrib) ##Total number of followers
    ##With the SWEEP function I multiply the Shadow Factor of each type (ShadowGroup columns) by the vProm result

    if (prom==TRUE){
        ## Average Shadow Factor in the group of SIX followers taking into account distribution
        FS=rowSums(sweep(SombraGrupo,2,vProm,'*'))/Nseg
        FS[FS>1]<-1
    } else {		
        ## Shadow factor on follower #5 due to the other 5 followers
        FS=rowSums(SombraGrupo)
        FS[FS>1]<-1}
    return(FS)
}
\end{lstlisting}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fSombraEst<-function(angGen, distances, struct)
{
    stopifnot(is.list(struct),is.data.frame(distances))
    ## I prepare starting data
    dist <- with(struct, distances/L)
    Alfa <- angGen$Alfa
    Beta <- angGen$Beta
    AlS <- angGen$AlS
    AzS <- angGen$AzS
    cosTheta <- angGen$cosTheta
    h <- dist$H #It must be previously normalized
    d <- dist$D                   
    ## Calculations
    s=cos(Beta)+cos(Alfa-AzS)*(sin(Beta)+h)/tan(AlS)
    FC=sin(AlS)/sin(Beta+AlS)
    SombraCond=(s-d>0)
    FS=(s-d)*SombraCond*FC*(cosTheta>0)
    ## Result
    FS=FS*(FS>0)
    FS[FS>1]<-1
    return(FS)
}
\end{lstlisting}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fSombraHoriz<-function(angGen, distances, struct)
{
    stopifnot(is.list(struct),is.data.frame(distances))
    ## I prepare starting data 	
    d <- with(struct, distances/L)
    AzS <- angGen$AzS
    AlS <- angGen$AlS
    Beta <- angGen$Beta
    lew <- d$Lew #It must be previously normalized
    ## Calculations
    Beta0=atan(abs(sin(AzS)/tan(AlS)))
    FS=1-lew*cos(Beta0)/cos(Beta-Beta0)
    SombraCond=(FS>0)
    ## Result
    FS=FS*SombraCond
    FS[FS>1]<-1
    return(FS)
}
\end{lstlisting}
\subsection{fTemp}
\label{sec:org638a2e9}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fTemp<-function(sol, BD)
{
    ##sol is an object with class='Sol'
    ##BD is an object with class='Meteo', whose 'data' slot contains two columns called "TempMax" and "TempMin"

    stopifnot(class(sol)=='Sol')
    stopifnot(class(BD)=='Meteo')

    checkIndexD(indexD(sol), indexD(BD))

    Dates<-indexI(sol)	
    x <- as.Date(Dates)
    ind.rep <- cumsum(c(1, diff(x) != 0))

    TempMax <-  BD@data$TempMax[ind.rep]
    TempMin <-  BD@data$TempMin[ind.rep]
    ws <- sol@solD$ws[ind.rep]
    w <- sol@solI$w

    ##Generate temperature sequence from database Maxima and Minima

    Tm=(TempMin+TempMax)/2
    Tr=(TempMax-TempMin)/2

    wp=pi/4

    a1=pi*12*(ws-w)/(21*pi+12*ws)
    a2=pi*(3*pi-12*w)/(3*pi-12*ws)
    a3=pi*(24*pi+12*(ws-w))/(21*pi+12*ws)

    T1=Tm-Tr*cos(a1)
    T2=Tm+Tr*cos(a2)
    T3=Tm-Tr*cos(a3)

    Ta=T1*(w<=ws)+T2*(w>ws&w<=wp)+T3*(w>wp)

    ##Result
    result<-data.table(Dates, Ta)
}
\end{lstlisting}
\subsection{fTheta}
\label{sec:org72e4a3b}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
fTheta<-function(sol, beta, alfa=0, modeTrk='fixed', betaLim=90, 
                 BT=FALSE, struct, dist)
{
    stopifnot(modeTrk %in% c('two','horiz','fixed'))
    if (!missing(struct)) {stopifnot(is.list(struct))}
    if (!missing(dist)) {stopifnot(is.data.frame(dist))}

    betaLim=d2r(betaLim)
    lat=getLat(sol, 'rad')
    signLat=ifelse(sign(lat)==0, 1, sign(lat)) ##When lat=0, sign(lat)=0. I change it to sign(lat)=1

    solI<-as.data.tableI(sol, complete=TRUE, day = TRUE)
    AlS=solI$AlS
    AzS=solI$AzS
    decl=solI$decl
    w<-solI$w

    night<-solI$night

    Beta<-switch(modeTrk,
                 two = {Beta2x=pi/2-AlS	
                     Beta=Beta2x+(betaLim-Beta2x)*(Beta2x>betaLim)},
                 fixed = rep(d2r(beta), length(w)), 
                 horiz={BetaHoriz0=atan(abs(sin(AzS)/tan(AlS)))
                     if (BT){lew=dist$Lew/struct$L
                         Longitud=lew*cos(BetaHoriz0)
                         Cond=(Longitud>=1)
                         Longitud[Cond]=1
                         ## When Cond==TRUE Length=1
                         ## and therefore asin(Length)=pi/2,
                         ## so that BetaHoriz=BetaHoriz0
                         BetaHoriz=BetaHoriz0+asin(Longitud)-pi/2                                     
                     } else {
                         BetaHoriz=BetaHoriz0
                         rm(BetaHoriz0)}
                     Beta=ifelse(BetaHoriz>betaLim,betaLim,BetaHoriz)}
                 )
    is.na(Beta) <- night

    Alfa<-switch(modeTrk,
                 two = AzS,
                 fixed = rep(d2r(alfa), length(w)),
                 horiz=pi/2*sign(AzS))
    is.na(Alfa) <- night

    cosTheta<-switch(modeTrk,
                     two=cos(Beta-(pi/2-AlS)),
                     horiz={
                         t1=sin(decl)*sin(lat)*cos(Beta)      
                         t2=cos(decl)*cos(w)*cos(lat)*cos(Beta)   
                         t3=cos(decl)*abs(sin(w))*sin(Beta)   
                         cosTheta=t1+t2+t3
                         rm(t1,t2,t3)
                         cosTheta
                     },
                     fixed={
                         t1=sin(decl)*sin(lat)*cos(Beta)      
                         t2=-signLat*sin(decl)*cos(lat)*sin(Beta)*cos(Alfa) 
                         t3=cos(decl)*cos(w)*cos(lat)*cos(Beta)   
                         t4=signLat*cos(decl)*cos(w)*sin(lat)*sin(Beta)*cos(Alfa) 
                         t5=cos(decl)*sin(w)*sin(Alfa)*sin(Beta)   
                         cosTheta=t1+t2+t3+t4+t5
                         rm(t1,t2,t3,t4,t5)
                         cosTheta
                     }
                     )
    is.na(cosTheta) <- night
    cosTheta=cosTheta*(cosTheta>0) #when cosTheta<0, Theta is greater than 90º, and therefore the Sun is behind the panel.

    result <- data.table(Dates = indexI(sol),
                         Beta, Alfa, cosTheta)
    return(result)
}
\end{lstlisting}
\subsection{HQCurve}
\label{sec:org29be7cb}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
## HQCurve: no visible binding for global variable ‘fb’
## HQCurve: no visible binding for global variable ‘Q’
## HQCurve: no visible binding for global variable ‘x’
## HQCurve: no visible binding for global variable ‘y’
## HQCurve: no visible binding for global variable ‘group.value’

if(getRversion() >= "2.15.1") globalVariables(c('fb', 'Q', 'x', 'y', 'group.value'))

HQCurve<-function(pump){
  w1=3000 #synchronous rpm frequency
  wm=2870 #rpm frequency with slip when applying voltage at 50 Hz
  s=(w1-wm)/w1
  fen=50 #Nominal electrical frequency

  f=seq(35,50,by=5)
  Hn=with(pump,a*50^2+b*50*Qn+c*Qn^2) #height corresponding to flow rate and nominal frequency

  kiso=Hn/pump$Qn^2 #To paint the isoyield curve I take into account the laws of similarity
  Qiso=with(pump,seq(0.1*Qn,Qmax,l=10))
  Hiso=kiso*Qiso^2 #Isoperformance curve

  Curva<-expand.grid(fb=f,Q=Qiso)

  Curva<-within(Curva,{
    fe=fb/(1-s)
    H=with(pump,a*fb^2+b*fb*Q+c*Q^2)

    is.na(H) <- (H<0)
    Q50=50*Q/fb
    H50=H*(50/fb)^2
    etab=with(pump,j*Q50^2+k*Q50+l)
    Pb50=2.725*H50*Q50/etab
    Pb=Pb50*(fb/50)^3

    Pbc=Pb*50/fe
    etam=with(pump,g*(Pbc/Pmn)^2+h*(Pbc/Pmn)+i)
    Pmc=Pbc/etam
    Pm=Pmc*fe/50

    etac=0.95 #Variable frequency drive performance
    cab=0.05  #Cable losses
    Pdc=Pm/(etac*(1-cab))
    rm(etac,cab,Pmc,Pbc,Pb50,Q50,H50)
  })

###H-Q curve at different frequencies
  ##I check if I have the lattice package available, which should have been loaded in .First.lib
  lattice.disp<-("lattice" %in% .packages())
  latticeExtra.disp<-("latticeExtra" %in% .packages())
  if (lattice.disp && latticeExtra.disp) {
    p<-xyplot(H~Q,groups=factor(fb),data=Curva, type='l',
              par.settings=custom.theme.2(),
              panel=function(x,y,groups,...){
                panel.superpose(x,y,groups,...)
                panel.xyplot(Qiso,Hiso,col='black',...)
                panel.text(Qiso[1], Hiso[1], 'ISO', pos=3)}
              )
    p=p+glayer(panel.text(x[1], y[1], group.value, pos=3))
    print(p)
    result<-list(result=Curva, plot=p)
  } else {
    warning('lattice and/or latticeExtra packages are not available. Thus, the plot could not be created')
    result<-Curva}
}
\end{lstlisting}
\subsection{local2Solar}
\label{sec:orgfa5fa20}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
local2Solar <- function(x, lon=NULL){	
  tz=attr(x, 'tzone')
  if (tz=='' || is.null(tz)) {tz='UTC'}
  ##Daylight savings time
  AO=3600*dst(x)
  AOneg=(AO<0)
  if (any(AOneg)) {
    AO[AOneg]=0
    warning('Some Daylight Savings Time unknown. Set to zero.')
  }
  ##Difference between local longitude and time zone longitude LH
  LH=lonHH(tz)
  if (is.null(lon)) 
    {deltaL=0
   } else
  {deltaL=d2r(lon)-LH
 }
  ##Local time corrected to UTC
  tt <- format(x, tz=tz)
  result <- as.POSIXct(tt, tz='UTC')-AO+r2sec(deltaL)
  result
}
\end{lstlisting}
\subsection{NmgPVPS}
\label{sec:orgabbcef1}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
## NmgPVPS: no visible binding for global variable ‘Pnom’
## NmgPVPS: no visible binding for global variable ‘group.value’

if(getRversion() >= "2.15.1") globalVariables(c('Pnom', 'group.value'))

NmgPVPS <- function(pump, Pg, H, Gd, Ta=30,
                    lambda=0.0045, TONC=47,
                    eta=0.95, Gmax=1200, t0=6, Nm=6,
                    title='', theme=custom.theme.2()){

    ##I build the type day by IEC procedure
    t=seq(-t0,t0,l=2*t0*Nm);
    d=Gd/(Gmax*2*t0)
    s=(d*pi/2-1)/(1-pi/4)
    G=Gmax*cos(t/t0*pi/2)*(1+s*(1-cos(t/t0*pi/2)))
    G[G<0]<-0
    G=G/(sum(G,na.rm=1)/Nm)*Gd
    Red<-expand.grid(G=G,Pnom=Pg,H=H,Ta=Ta)
    Red<-within(Red,{Tcm<-Ta+G*(TONC-20)/800
                     Pdc=Pnom*G/1000*(1-lambda*(Tcm-25)) #Available DC power
                     Pac=Pdc*eta})                       #Inverter yield

    res=data.table(Red,Q=0)

    for (i in seq_along(H)){
        fun=fPump(pump, H[i])
        Cond=res$H==H[i]
        x=res$Pac[Cond]
        z=res$Pdc[Cond]
        rango=with(fun,x>=lim[1] & x<=lim[2]) #I limit the power to the operating range of the pump.
        x[!rango]<-0
        z[!rango]<-0
        y=res$Q[Cond]
        y[rango]<-fun$fQ(x[rango])
        res$Q[Cond]=y
        res$Pac[Cond]=x
        res$Pdc[Cond]=z
    }

    resumen <- res[, lapply(.SD, function(x)sum(x, na.rm = 1)/Nm),
                   by = .(Pnom, H)]
    param=list(pump=pump, Pg=Pg, H=H, Gd=Gd, Ta=Ta,
               lambda=lambda, TONC=TONC, eta=eta,
               Gmax=Gmax, t0=t0, Nm=Nm)


###Abacus with common X-axes

    ##I check if I have the lattice package available, which should have been loaded in .First.lib
    lattice.disp<-("lattice" %in% .packages())
    latticeExtra.disp<-("latticeExtra" %in% .packages())
    if (lattice.disp && latticeExtra.disp){
        tema<-theme
        tema1 <- modifyList(tema, list(layout.width = list(panel=1,
                                       ylab = 2, axis.left=1.0,
                                       left.padding=1, ylab.axis.padding=1,
                                       axis.panel=1)))
        tema2 <- modifyList(tema, list(layout.width = list(panel=1,
                                       ylab = 2, axis.left=1.0, left.padding=1,
                                       ylab.axis.padding=1, axis.panel=1)))
        temaT <- modifyList(tema, list(layout.heights = list(panel = c(1, 1))))
        p1 <- xyplot(Q~Pdc, groups=H, data=resumen,
                     ylab="Qd (m\u00b3/d)",type=c('l','g'),
                     par.settings = tema1)

        p1lab<-p1+glayer(panel.text(x[1], y[1], group.value, pos=2, cex=0.7))

        ##I paint the linear regression because Pnom~Pdc depends on the height.
        p2 <- xyplot(Pnom~Pdc, groups=H, data=resumen,
                     ylab="Pg",type=c('l','g'), #type=c('smooth','g'),
                     par.settings = tema2)
        p2lab<-p2+glayer(panel.text(x[1], y[1], group.value, pos=2, cex=0.7))

        p<-update(c(p1lab, p2lab, x.same = TRUE),
                  main=paste(title, '\nSP', pump$Qn, 'A', pump$stages, ' ',
                  'Gd ', Gd/1000," kWh/m\u00b2",sep=''),
                  layout = c(1, 2),
                  scales=list(x=list(draw=FALSE)),
                  xlab='',              
                  ylab = list(c("Qd (m\u00b3/d)","Pg (Wp)"), y = c(1/4, 3/4)),
                  par.settings = temaT
                  )
        print(p)
        result<-list(I=res,D=resumen, plot=p, param=param)
    } else {
        warning('lattice, latticeExtra packages are not all available. Thus, the plot could not be created')
        result<-list(I=res,D=resumen, param=param)
    }
}
\end{lstlisting}
\subsection{utils-angle}
\label{sec:orga9b18d4}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
#degrees to radians
d2r<-function(x){x*pi/180}

#radians to degrees
r2d<-function(x){x*180/pi}

#hours to radians
h2r<-function(x){x*pi/12}

#hours to degrees
h2d<-function(x){x*180/12}

#radians to hours
r2h<-function(x){x*12/pi}

#degrees to hours
d2h<-function(x){x*12/180}

#radians to seconds
r2sec<-function(x){x*12/pi*3600}

#radians to minutes
r2min<-function(x){x*12/pi*60}
\end{lstlisting}
\subsection{utils-time}
\label{sec:orgec4eef9}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
#complete time to hours
t2h <- function(x)
{
    hour(x)+minute(x)/60+second(x)/3600
}

#hours minutes and seconds to hours
hms <- function(x)
{
    hour(x)+minute(x)/60+second(x)/3600
}

#day of the year
doy <- function(x){
  as.numeric(format(x, '%j'))
}

#day of the month
dom <- function(x){
  as.numeric(format(x, '%d'))
}

#trunc days
truncDay <- function(x){as.POSIXct(trunc(x, units='days'))}
\end{lstlisting}
\section{Métodos}
\label{sec:orgbc9e4af}
\subsection{as.data.tableI}
\label{sec:org9e4e50f}
\subsection{as.data.tableD}
\label{sec:org22de437}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setGeneric('as.data.tableD', function(object, complete=FALSE, day=FALSE){standardGeneric('as.data.tableD')})

setMethod('as.data.tableD',
          signature=(object='Sol'),
          definition=function(object, complete=FALSE, day=FALSE){
              sol <- copy(object)
              solD <- sol@solD
              data <- solD
              if(day){
                  ind <- indexD(object)
                  data[, day := doy(ind)]
                  data[, month := month(ind)]
                  data[, year := year(ind)]
              }
              return(data)
          }
          )

setMethod('as.data.tableD',
          signature = (object='G0'),
          definition = function(object, complete=FALSE, day=FALSE){
              g0 <- copy(object)
              G0D <- g0@G0D
              solD <- g0@solD
              if(complete){
                  data <- data.table(G0D, solD[, Dates := NULL])
              } else {
                  G0D[, Fd := NULL]
                  G0D[, Kt := NULL]
                  data <- G0D
              }
              if(day){
                  ind <- indexD(object)
                  data[, day := doy(ind)]
                  data[, month := month(ind)]
                  data[, year := year(ind)]
              }
              return(data)
          })

setMethod('as.data.tableD',
          signature = (object='Gef'),
          definition = function(object, complete=FALSE, day=FALSE){
              gef <- copy(object)
              GefD <- gef@GefD
              G0D <- gef@G0D
              solD <- gef@solD
              if(complete){
                  data <- data.table(GefD,
                                     G0D[, Dates := NULL],
                                     solD[, Dates := NULL])
              } else {data <- GefD[, c('Dates', 'Gefd',
                                       'Defd', 'Befd')]}
              if(day){
                  ind <- indexD(object)
                  data[, day := doy(ind)]
                  data[, month := month(ind)]
                  data[, year := year(ind)]     
              }
              return(data)
          }
          )

setMethod('as.data.tableD',
          signature = (object='ProdGCPV'),
          definition = function(object, complete=FALSE, day=FALSE){
              prodgcpv <- copy(object)
              prodD <- prodgcpv@prodD
              GefD <- prodgcpv@GefD
              G0D <- prodgcpv@G0D
              solD <- prodgcpv@solD
              if(complete){
                  data <- data.table(prodD,
                                     GefD[, Dates := NULL],
                                     G0D[, Dates := NULL],
                                     solD[, Dates := NULL]
                                     )
              } else { data <- prodD[, c('Dates', 'Eac',
                                         'Edc', 'Yf')]}
              if(day){
                  ind <- indexD(object)
                  data[, day := doy(ind)]
                  data[, month := month(ind)]
                  data[, year := year(ind)]
              }
              return(data)
          }
          )

setMethod('as.data.tableD',
          signature = (object='ProdPVPS'),
          definition = function(object, complete=FALSE, day=FALSE){
              prodpvps <- copy(object)
              prodD <- prodpvps@prodD
              GefD <- prodpvps@GefD
              G0D <- prodpvps@G0D
              solD <- prodpvps@solD
              if(complete){
                  data <- data.table(prodD,
                                     GefD[, Dates := NULL],
                                     G0D[, Dates := NULL],
                                     solD[, Dates := NULL]
                                     )
              } else { data <- prodD[, c('Dates', 'Eac',
                                         'Qd', 'Yf')]}
              if(day){
                  ind <- indexD(object)
                  data[, day := doy(ind)]
                  data[, month := month(ind)]
                  data[, year := year(ind)]
              }
              return(data)
          }
          )
\end{lstlisting}
\subsection{as.data.tableM}
\label{sec:org211fdf7}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setGeneric('as.data.tableM', function(object, complete = FALSE, day=FALSE){standardGeneric('as.data.tableM')})

setMethod('as.data.tableM',
          signature=(object='G0'),
          definition=function(object, complete=FALSE, day=FALSE){
              g0 <- copy(object)
              G0dm <- g0@G0dm
              data <- G0dm
              if(day){
                  ind <- indexD(object)
                  data[, month := month(ind)]
                  data[, year := year(ind)]
              }
              return(data)
          }
          )

setMethod('as.data.tableM',
          signature=(object='Gef'),
          definition = function(object, complete=FALSE, day=FALSE){
              gef <- copy(object)
              Gefdm <- gef@Gefdm
              G0dm <- gef@G0dm
              if(complete){
                  data <- data.table(Gefdm, G0dm[, Dates := NULL])
              } else {data <- Gefdm}
              if(day){
                  ind <- indexD(object)
                  data[, month := month(ind)]
                  data[, year := year(ind)]
              }
              return(data)
          }
          )

setMethod('as.data.tableM',
          signature = (object='ProdGCPV'),
          definition = function(object, complete=FALSE, day=FALSE){
              prodgcpv <- copy(object)
              prodDm <- prodgcpv@prodDm
              Gefdm <- prodgcpv@Gefdm
              G0dm <- prodgcpv@G0dm
              if(complete){
                  data <- data.table(prodDm,
                                     Gefdm[, Dates := NULL],
                                     G0dm[, Dates := NULL])
              } else {data <- prodDm}
              if(day){
                  ind <- indexD(object)
                  data[, month := month(ind)]
                  data[, year := year(ind)]
              }
              return(data)
          }
          )

setMethod('as.data.tableM',
          signature = (object='ProdPVPS'),
          definition = function(object, complete=FALSE, day=FALSE){
              prodpvps <- copy(object)
              prodDm <- prodpvps@prodDm
              Gefdm <- prodpvps@Gefdm
              G0dm <- prodpvps@G0dm
              if(complete){
                  data <- data.table(prodDm,
                                     Gefdm[, Dates := NULL],
                                     G0dm[, Dates := NULL])
              } else {data <- prodDm}
              if(day){
                  ind <- indexD(object)
                  data[, month := month(ind)]
                  data[, year := year(ind)]
              }
              return(data)
          }
          )
\end{lstlisting}
\subsection{as.data.tableY}
\label{sec:org43c908d}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setGeneric('as.data.tableY', function(object, complete=FALSE, day=FALSE){standardGeneric('as.data.tableY')})

setMethod('as.data.tableY',
          signature=(object='G0'),
          definition=function(object, complete=FALSE, day=FALSE){
              g0 <- copy(object)
              G0y <- g0@G0y
              data <- G0y
              if(day){data[, year := Dates]}
              return(data)
          }
          )

setMethod('as.data.tableY',
          signature = (object='Gef'),
          definition = function(object, complete=FALSE, day=FALSE){
              gef <- copy(object)
              Gefy <- gef@Gefy
              G0y <- gef@G0y
              if(complete){
                  data <- data.table(Gefy, G0y[, Dates := NULL])
              } else {data <- Gefy}
              if(day){data[, year := Dates]}
              return(data)
          }
          )

setMethod('as.data.tableY',
          signature = (object='ProdGCPV'),
          definition = function(object, complete=FALSE, day=FALSE){
              prodgcpv <- copy(object)
              prody <- prodgcpv@prody
              Gefy <- prodgcpv@Gefy
              G0y <- prodgcpv@G0y
              if(complete){
                  data <- data.table(prody,
                                     Gefy[, Dates := NULL],
                                     G0y[, Dates := NULL])       
              } else {data <- prody}
              if(day){data[, year := Dates]}
              return(data)
          }
          )

setMethod('as.data.tableY',
          signature = (object='ProdPVPS'),
          definition = function(object, complete=FALSE, day=FALSE){
              prodpvps <- copy(object)
              prody <- prodpvps@prody
              Gefy <- prodpvps@Gefy
              G0y <- prodpvps@G0y
              if(complete){
                  data <- data.table(prody,
                                     Gefy[, Dates := NULL],
                                     G0y[, Dates := NULL])       
              } else {data <- prody}
              if(day){data[, year := Dates]}
              return(data)
          }
          )
\end{lstlisting}
\subsection{compare}
\label{sec:org6478739}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
## compareFunction: no visible binding for global variable ‘name’
## compareFunction: no visible binding for global variable ‘x’
## compareFunction: no visible binding for global variable ‘y’
## compareFunction: no visible binding for global variable ‘group.value’

if(getRversion() >= "2.15.1") globalVariables(c('name', 'x', 'y', 'group.value'))

setGeneric('compare', signature='...', function(...){standardGeneric('compare')})

compareFunction <- function(..., vars){
    dots <- list(...)
    nms0 <- substitute(list(...))
    if (!is.null(names(nms0))){ ##in do.call
        nms <- names(nms0[-1])
    } else {
        nms <- as.character(nms0[-1])
    }
    foo <- function(object, label){
        yY <- colMeans(as.data.tableY(object, complete = TRUE)[, ..vars])
        yY <- cbind(stack(yY), name=label)
        yY
    }
    cdata <- mapply(FUN=foo, dots, nms, SIMPLIFY=FALSE)
    z <- do.call(rbind, cdata)
    z$ind <- ordered(z$ind, levels=vars)
    p <- dotplot(ind~values, groups=name, data=z, type='b',
                 par.settings=solaR.theme)
    print(p+glayer(panel.text(x[length(x)], y[length(x)],
                              label=group.value, cex=0.7, pos=3, srt=45)))
    return(z)
}


setMethod('compare',
          signature='G0',
          definition=function(...){
            vars <- c('D0d', 'B0d', 'G0d')
            res <- compareFunction(..., vars=vars)
            return(res)
          }
          )

setMethod('compare',
          signature='Gef',
          definition=function(...){
            vars <- c('Defd', 'Befd', 'Gefd')
            res <- compareFunction(..., vars=vars)
            return(res)
          }
          )

setMethod('compare',
          signature='ProdGCPV',
          definition=function(...){
            vars <- c('G0d', 'Gefd', 'Yf')
            res <- compareFunction(..., vars=vars)
            return(res)
          }
          )
\end{lstlisting}
\subsection{getData}
\label{sec:org0de9a26}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
## extracts the data for class Meteo ##
setGeneric('getData', function(object){standardGeneric('getData')})

### getData ####
setMethod('getData',
          signature = (object = 'Meteo'),
          definition = function(object){
              result <- object@data
              return(result)
          })
\end{lstlisting}
\subsection{getG0}
\label{sec:org0c8b4b9}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
## extracts the global irradiance for class Meteo ##
setGeneric('getG0', function(object){standardGeneric('getG0')})

### getG0 ###
setMethod('getG0',
          signature = (object = 'Meteo'),
          definition = function(object){
              result <- getData(object)
              return(result$G0)
          })
\end{lstlisting}
\subsection{getLat}
\label{sec:orgda90380}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
## extracts the latitude from the objects ##
setGeneric('getLat', function(object, units = 'rad')
{standardGeneric('getLat')})

## extracts the latitude from the objects ##
setGeneric('getLat', function(object, units = 'rad')
{standardGeneric('getLat')})

setMethod('getLat',
          signature = (object = 'Meteo'),
          definition = function(object, units = 'rad'){
              stopifnot(units %in% c('deg', 'rad'))
              result = switch(units,
                              rad = d2r(object@latm),
                              deg = object@latm)
              return(result)
          })
\end{lstlisting}
\subsection{indexD}
\label{sec:orga6dcc04}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
## extract the index of the daily data ##
setGeneric('indexD', function(object){standardGeneric('indexD')})
### indexD ###
setMethod('indexD',
          signature = (object = 'Sol'),
          definition = function(object){as.POSIXct(object@solD$Dates)
          })

setMethod('indexD',
          signature = (object = 'Meteo'),
          definition = function(object){as.POSIXct(getData(object)$Dates)})
\end{lstlisting}
\subsection{indexI}
\label{sec:org405df9d}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
## extract the index of the intradaily data ##
setGeneric('indexI', function(object){standardGeneric('indexI')})
### indexI ###
setMethod('indexI',
          signature = (object = 'Sol'),
          definition = function(object){as.POSIXct(object@solI$Dates)
          })
\end{lstlisting}
\subsection{levelplot}
\label{sec:org1b27851}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setGeneric('levelplot')

## setMethod('levelplot',
##           signature=c(x='formula', data='zoo'),
##           definition=function(x, data,
##             par.settings=solaR.theme,
##             ##            panel=panel.levelplot.raster, interpolate=TRUE,...){
##             xscale.components=xscale.solar,
##             yscale.components=yscale.solar,
##             ...){
##             data0=as.data.frame(data)
##             ind=index(data)
##             data0$day=doy(ind) ##Incorporo dia, mes y año para facilitar la formula.
##             data0$month=month(ind)
##             data0$year=year(ind)
##             if (!('w' %in% names(data0))){
##               data0$w=h2r(hms(ind)-12) ##hora solar en radianes
##             }
##             levelplot(x, data0, par.settings=par.settings,
##                       xscale.components=xscale.components,
##                       yscale.components=yscale.components,
##                       ##                     panel=panel, interpolate=interpolate,
##                       ...)
##           }
##           )


setMethod('levelplot',
          signature=c(x='formula', data='Meteo'),
          definition=function(x, data,
                              par.settings = solaR.theme,
                              panel = panel.levelplot.raster, interpolate = TRUE,
                              xscale.components = xscale.solar,
                              yscale.components = yscale.solar,
                              ...){
            data0=getData(data)
            levelplot(x, data0,
                      par.settings = par.settings,
                      xscale.components = xscale.components,
                      yscale.components = yscale.components,
                      panel = panel, interpolate = interpolate,
                      ...)
          }
          )

setMethod('levelplot',
          signature=c(x='formula', data='Sol'),
          definition=function(x, data,
                              par.settings = solaR.theme,
                              panel = panel.levelplot.raster, interpolate = TRUE,
                              xscale.components = xscale.solar,
                              yscale.components = yscale.solar,
                              ...){
            data0=as.data.tableI(data, complete=TRUE, day=TRUE)
            levelplot(x, data0,
                      par.settings = par.settings,
                      xscale.components = xscale.components,
                      yscale.components = yscale.components,
                      panel = panel, interpolate = interpolate,
                      ...)
          }
          )

setMethod('levelplot',
          signature=c(x='formula', data='G0'),
          definition=function(x, data,
                              par.settings = solaR.theme,
                              panel = panel.levelplot.raster, interpolate = TRUE,
                              xscale.components = xscale.solar,
                              yscale.components = yscale.solar,
                              ...){
            data0=as.data.tableI(data, complete=TRUE, day=TRUE)
            levelplot(x, data0, 
                      par.settings = par.settings,
                      xscale.components = xscale.components,
                      yscale.components = yscale.components,
                      panel = panel, interpolate = interpolate,
                      ...)
          }
          )
\end{lstlisting}
\subsection{losses}
\label{sec:org2ef65dd}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setGeneric('losses', function(object){standardGeneric('losses')})

setMethod('losses',
          signature=(object='Gef'),
          definition=function(object){
            dat <- as.data.tableY(object, complete=TRUE)
            isShd=('Gef0d' %in% names(dat)) ##is there shadows?
            if (isShd) {
              shd <- with(dat, mean(1-Gefd/Gef0d))
              eff <- with(dat, mean(1-Gef0d/Gd))
            } else {
              shd <- 0
              eff <- with(dat, mean(1-Gefd/Gd))
            }
            result <- data.table(Shadows = shd, AoI = eff)
            result
          }
          )

setMethod('losses',
          signature=(object='ProdGCPV'),
          definition=function(object){
              datY <- as.data.tableY(object, complete=TRUE)
              module0=object@module
              module0$CoefVT=0 ##No losses with temperature
              Pg=object@generator$Pg
              Nm=1/sample2Hours(object@sample)
              datI <- as.data.tableI(object, complete=TRUE)
              if (object@type=='prom'){
                  datI[, DayOfMonth := DOM(datI)]
                  YfDC0 <- datI[, sum(Vmpp*Impp/Pg*DayOfMonth, na.rm = TRUE),
                                by = month(Dates)][[2]]
                  YfDC0 <- sum(YfDC0, na.rm = TRUE)
                  YfAC0 <- datI[, sum(Pdc*EffI/Pg*DayOfMonth, na.rm = TRUE),
                                by = month(Dates)][[2]]
                  YfAC0 <- sum(YfAC0, na.rm = TRUE)
              } else {
                  datI[, DayOfMonth := DOM(datI)]
                  YfDC0 <- datI[, sum(Vmpp*Impp/Pg*DayOfMonth, na.rm = TRUE),
                                by = year(Dates)][[2]]
                  YfAC0 <- datI[, sum(Pdc*EffI/Pg*DayOfMonth, na.rm = TRUE),
                                by = year(Dates)][[2]]     
              }
              gen <- mean(1-YfDC0/datY$Gefd)
              YfDC <- datY$Edc/Pg*1000
              DC=mean(1-YfDC/YfDC0)
              inv=mean(1-YfAC0/YfDC)
              AC=mean(1-datY$Yf/YfAC0)
              result0 <- losses(as(object, 'Gef'))
              result1 <- data.table(Generator = gen,
                                    DC = DC,
                                    Inverter = inv,
                                    AC = AC)
              result <- data.table(result0, result1)
              result
          }
          )

###compareLosses

## compareLosses,ProdGCPV: no visible binding for global variable ‘name’
if(getRversion() >= "2.15.1") globalVariables(c('name'))

setGeneric('compareLosses', signature='...', function(...){standardGeneric('compareLosses')})

setMethod('compareLosses', 'ProdGCPV',
          definition=function(...){
            dots <- list(...)
            nms0 <- substitute(list(...))
            if (!is.null(names(nms0))){ ##do.call
              nms <- names(nms0[-1])
            } else {
              nms <- as.character(nms0[-1])
            }
            foo <- function(object, label){
              yY <- losses(object)
              yY <- cbind(yY, name=label)
              yY
            }
            cdata <- mapply(FUN=foo, dots, nms, SIMPLIFY=FALSE)
            z <- do.call(rbind, cdata)
            z <- melt(z, id.vars = 'name')
            p <- dotplot(variable~value*100, groups=name, data=z,
                         par.settings=solaR.theme, type='b',
                         auto.key=list(corner=c(0.95,0.2), cex=0.7), xlab='Losses (%)')
            print(p)
            return(z)
          }
          )
\end{lstlisting}
\subsection{mergeSolar}
\label{sec:orgb99493b}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setGeneric('mergesolaR', signature='...', function(...){standardGeneric('mergesolaR')})

fooMeteo <- function(object, var){yY <- getData(object)[, .SD,
                                                        by = Dates,
                                                        .SDcols = var]}

fooG0 <- function(object, var){yY <- as.data.tableD(object)[, .SD,
                                                            by = Dates,
                                                            .SDcols = var]}

mergeFunction <- function(..., foo, var){
    dots <- list(...)
    dots <- lapply(dots, as, class(dots[[1]])) ##the first element is the one that dictates the class to everyone
    nms0 <- substitute(list(...))
    if (!is.null(names(nms0))){ ##do.call
        nms <- names(nms0[-1])
    } else { 
        nms <- as.character(nms0[-1])
    }
    cdata <- sapply(dots, FUN=foo, var, simplify=FALSE)
    z <- cdata[[1]]
    for (i in 2:length(cdata)){
        z <- merge(z, cdata[[i]], by = 'Dates', suffixes = c("", paste0('.', i)))
    }
    names(z)[-1] <- nms
    z
}

setMethod('mergesolaR',
          signature='Meteo',
          definition=function(...){
            res <- mergeFunction(..., foo=fooMeteo, var='G0')
            res
          }
          )

setMethod('mergesolaR',
          signature='G0',
          definition=function(...){
            res <- mergeFunction(..., foo=fooG0, var='G0d')
            res
          }
          )

setMethod('mergesolaR',
          signature='Gef',
          definition=function(...){
            res <- mergeFunction(..., foo=fooG0, var='Gefd')
            res
          }
          )

setMethod('mergesolaR',
          signature='ProdGCPV',
          definition=function(...){
            res <- mergeFunction(..., foo=fooG0, var='Yf')
            res
          }
          )

setMethod('mergesolaR',
          signature='ProdPVPS',
          definition=function(...){
            res <- mergeFunction(..., foo=fooG0, var='Yf')
            res
          }
          )
\end{lstlisting}
\subsection{shadeplot}
\label{sec:orgee6e426}
\begin{lstlisting}[numbers=left,language=r,label= ,caption= ,captionpos=b]
setGeneric('shadeplot', function(x, ...)standardGeneric('shadeplot'))

setMethod('shadeplot', signature(x='Shade'),
          function(x,
                   main='',
                   xlab=expression(L[ew]),
                   ylab=expression(L[ns]),
                   n=9, ...){
              red=x@distances
              FS.loess=x@FS.loess
              Yf.loess=x@Yf.loess
              struct=x@struct
              mode=x@modeTrk
              if (mode=='two'){
                  Lew=seq(min(red$Lew),max(red$Lew),length=100)
                  Lns=seq(min(red$Lns),max(red$Lns),length=100)
                  Red=expand.grid(Lew=Lew,Lns=Lns)
                  FS=predict(FS.loess,Red)
                  Red$FS=as.numeric(FS)
                  AreaG=with(struct,L*W)
                  GRR=Red$Lew*Red$Lns/AreaG
                  Red$GRR=GRR
                  FS.m<-matrix(1-FS,
                               nrow=length(Lew),
                               ncol=length(Lns))
                  GRR.m<-matrix(GRR,
                                nrow=length(Lew),
                                ncol=length(Lns))
                  niveles=signif(seq(min(FS.m),max(FS.m),l=n+1),3)
                  pruebaCB<-("RColorBrewer" %in% .packages())
                  if (pruebaCB) {
                      paleta=rev(brewer.pal(n, 'YlOrRd'))
                  } else {
                      paleta=rev(heat.colors(n))}
                  par(mar=c(4.1,4.1,2.1,2.1)) 
                  filled.contour(x=Lew,y=Lns,z=FS.m,#...,
                                 col=paleta, #levels=niveles,
                                 nlevels=n,
                                 plot.title=title(xlab=xlab,
                                                  ylab=ylab, main=main),
                                 plot.axes={
                                     axis(1);axis(2);
                                     contour(Lew, Lns, FS.m,
                                             nlevels=n, #levels=niveles,
                                             col="black", labcex=.8,  add=TRUE)
                                     contour(Lew, Lns, GRR.m,
                                             col="black", lty=3, labcex=.8, add=TRUE)
                                     grid(col="white",lty=3)},
                                 key.title=title("1-FS",cex.main=.8))
              }
              if (mode=='horiz') {
                  Lew=seq(min(red$Lew),max(red$Lew),length=100)
                  FS=predict(FS.loess,Lew)
                  GRR=Lew/struct$L
                  plot(GRR,1-FS,main=main,type='l',...)
                  grid()    }
              if (mode=='fixed'){
                  D=seq(min(red$D),max(red$D),length=100)
                  FS=predict(FS.loess,D)
                  GRR=D/struct$L
                  plot(GRR,1-FS,main=main,type='l',...)
                  grid()    }
          }
          )
\end{lstlisting}
