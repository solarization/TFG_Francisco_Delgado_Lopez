#+PROPERTY: header-args:R :dir . :session *R* :exports both :results output
\chapter{Desarrollo del código}
label:chap:desarrollo-codigo
En la figura [[fig:prod-solar2]], se muestra el proceso de cálculo que sigue el paquete a la hora de obtener la estimación de la producción del sistema fotovoltaico.
#+ATTR_LATEX: :height 0.5\textheight :width 0.8\textwidth :options keepaspectratio
#+CAPTION: Proceso de cálculo de las funciones de =solaR2=
#+NAME: fig:prod-solar2
[[file:figuras/procedure.pdf]]
A la hora de estimar la producción, el programa sigue los siguientes procesos:
* Geometría solar
label:sec:geometria-solar
Para calcular la geometría que definen las posiciones de la Tierra y el Sol, =solaR2= se vale de una función constructora, =calcSol= [ref:subsec:calcsol], la cual mediante las funciones =fSolD= [ref:subsec:fsold] y =fSolI= [ref:subsec:fsoli] cálcula todos los ángulos y componentes que caracterizan la geometría solar.
#+CAPTION: Cálculo de la geometría solar mediante la función =calcSol=, la cual unifica las funciones =fSolD= y =fSolI= resultando en un objeto clase =Sol= el cual contiene toda la información geométrica necesaria para realizar las siguientes estimaciones. label:fig:calcSol
#+ATTR_LATEX: :height 0.5\textheight :width \textwidth :options keepaspectratio
[[file:figuras/calcSol.pdf]]

Como se puede ver en la figura ref:fig:calcSol, =calcSol= funcia gracias a las siguientes funciones:
- =fSolD=: la cual, a partir de la latitud (\(\phi\)), computa la geometría a nivel diario, es decir, los ángulos y componentes que se pueden calcular en cada día independiente.

  estas son:
  - Declinación (\(\delta\)): calculada a partir de la función =declination=[fn:1].
  - Excentricidad (\(\epsilon_o\)): obtenida mediante la función =eccentricity=.
  - Ecuación del tiempo (\(EoT\)): obtenida mediante la función =eot=.
  - Ángulo del amanecer (\(\omega_s\)): calculada a partir de la función =sunrise=.
  - Irradiancia diaria extra-atmosférica (\(B_{0d}(0)\)): obtenida a paritr de la función =bo0d=.
#+begin_src R :exports none
  library(solaR2)
  library(zoo)
  library(httr2)
  library(jsonlite)
  setwd('TFG')
#+end_src
#+begin_src R 
lat <- 40
BTd <- fBTd(mode = 'prom')
fSolD(lat = lat, BTd = BTd)
show(solD)
#+end_src

  Además, =fSolD= permite seleccionar el método de cáculo entre los propuestos por 4 autores diferentes (=cooper= cite:Cooper1969, =spencer= cite:Spencer1971, =strous= cite:Strous2011, =michalsky= cite:Michalsky1988)(el valor por defecto es =michalsky=):
#+begin_src R 
solD_cooper <- fSolD(lat = lat, BTd = BTd, method = 'cooper')
show(solD_cooper)
#+end_src
#+begin_src R
solD_spencer <- fSolD(lat = lat, BTd = BTd, method = 'spencer')
show(solD_spencer)
#+end_src
#+begin_src R
solD_strous <- fSolD(lat = lat, BTd = BTd, method = 'cooper')
show(solD_strous)
#+end_src
- =fSolI=: toma los resultados obtenidos en =fSolD= y calcula la geometría a nivel intradiario, es decir, aquella que se puede calcular en unidades de tiempo menores a los días.
  estas son:
  - La hora solar o tiempo solar verdadero (\(\omega\)): calculada a partir de la función =sunHour=.
  - Los momentos del día en los que es de noche (\(night\)): calculada a partir del resultado anterior y de el ángulo del amanecer (cálculada en =fSolD=)[fn:2].
  - El coseno del ángulo cenital solar (\(cos(\theta_{zs})\)): obtenida a partir de la función =zenith=.
  - La altura solar (\(\gamma_s\)): obtenida a partir del resultado anterior[fn:3].
  - El ángulo zenital solar (\(\theta_{zs}\)): calculada mediante la función =azimuth=.
  - La irradiancia extra-atmosférica (\(B_0(0)\)): calculada mediante el coseno del ángulo cenital, la constante solar (\(B_0\)) y la excentridad (cálculada en =fSolD=) [ecuación ref:eq:irrad_horiz].
#+begin_src R
solI <- fSolI(solD = solD[1], sample = 'hour') #Computo solo un día a fin mejorar la visualización
show(solI)
#+end_src

  Además, como los datos nocturnos aportan poco a los cálculos que atañen a este proyecto, =fSolI= presenta la posibilidad de eliminar estos datos con el argumento =keep.night=.
#+begin_src R
solI_nigth <- fSolI(solD = solD[1], sample = 'hour', keep.night = FALSE)
show(solI_nigth)
#+end_src

Finalmente, estas dos funciones, como se muestra en la figura ref:fig:calcSol, convergen en la función =calcSol=, dando como resultado un objeto de clase =Sol=. Este objeto muestra un sumario de ambos elementos junto con la latitud de los cálculos.
#+begin_src R
sol <- calcSol(lat = lat, BTd = BTd, sample = 'hour')
print(sol)
#+end_src

* Datos meteorológicos
label:sec:datos-meteorologicos
Para el procesamiento de datos meteorologicos, =solaR2= provee una serie de funciones[fn:4] que son capaces de leer todo tipo de datos. Estos datos se procesan y se almacenan en un objeto de tipo =Meteo= tal y como se ve en la figura ref:fig:meteo. Estas funciones son:
#+CAPTION: Los datos meteorologicas se pueden leer mediante las funciones =readG0dm=, =readBD=, =dt2Meteo=, =zoo2Meteo= y =readSIAR= las cuales procesan estos datos y los almacenan en un objeto de clase =Meteo=. label:fig:meteo
#+ATTR_LATEX: :height 0.5\textheight :width \textwidth :options keepaspectratio 
file:figuras/meteo.pdf
- =readG0dm=: Esta función construye un objeto =Meteo= a partir de 12 valores de medias mensuales de irradiación.
#+begin_src R
G0dm = c(2.766,3.491,4.494,5.912,6.989,7.742,
         7.919,7.027,5.369,3.562,2.814,2.179) * 1000;
Ta = c(10, 14.1, 15.6, 17.2, 19.3, 21.2,
       28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
BD <- readG0dm(G0dm = G0dm, Ta = Ta, lat = 37.2)
print(BD)
#+end_src
- =readBD=: Esta familia de funciones puede leer ficheros de datos y transformarlos en un objeto de clase =Meteo=. Se dividen en:
  - =readBDd=: Procesa datos meteorológicos de tipo diarios.
  #+begin_src R
  ## Se utiliza un archivo alojado en el
  ## github del tutor de este proyecto 
  myURL <-"https://raw.githubusercontent.com/oscarperpinan/R/master/data/aranjuez.csv"
  download.file(myURL, 'data/aranjuez.csv', quiet = TRUE)
  BDd <- readBDd(file = 'data/aranjuez.csv', lat = lat,
		 format = '%Y-%m-%d', header = TRUE,
		 fill = TRUE, dec = '.', sep = ',', dates.col = '',
		 ta.col = 'TempAvg', g0.col = 'Radiation', keep.cols = TRUE)
  print(BDd)
  #+end_src
  - =readBDi=: Procesa datos meteorológicos de tipo intradiarios.
  #+begin_src R
    myURL <- "https://raw.githubusercontent.com/oscarperpinan/R/master/data/NREL-Hawaii.csv"
    download.file(myURL, 'data/NREL-Hawaii.csv', quiet = TRUE)
    BDi <- readBDi(file = 'data/NREL-Hawaii.csv', lat = 19,
		   format = "%d/%m/%Y %H:%M", header = TRUE,
		   fill = TRUE, dec = '.', sep = ',',
		   dates.col = 'DATE', times.col = 'HST',
		   ta.col = 'Air Temperature [deg C]',
		   g0.col = 'Global Horizontal [W/m^2]',
		   keep.cols = TRUE)
    print(BDi)
  #+end_src
- =dt2Meteo=: Transforma un =data.table= o =data.frame= en un objeto de clase =Meteo=.
#+begin_src R
  data(helios)
  names(helios) <- c('Dates', 'G0d', 'TempMax', 'TempMin')
  helios_meteo <- dt2Meteo(file = helios, lat = 40, type = 'bd')
  print(helios_meteo)
#+end_src  
- =zoo2Meteo=: Transforma un objeto de clase =zoo=[fn:5] en un objeto de clase =Meteo=.
#+begin_src R
  library(zoo)
  bd_zoo <- read.csv.zoo('data/aranjuez.csv')
  BD_zoo <- zoo2Meteo(file = bd_zoo, lat = 40)
  print(BD_zoo)
#+end_src
- =readSIAR=: Esta función es capaz de extraer información de la red SIAR y transformarlo en un objeto de clase =Meteo=.
#+begin_src R
  library(httr2)
  library(jsonlite)
  bd_SIAR <- readSIAR(Lat = 40.40596822621351, Lon = -3.70038308516172,
		      ## Ubicación de la Escuela Técnica Superior
		      ## de Ingeniería y Diseño Industrial (ETSIDI)
		      inicio = '2023-09-01', final = '2024-08-01',
		      tipo = 'Mensuales', n_est = 3)
  print(bd_SIAR)
#+end_src
  Esta función tiene dos argumentos importantes:
  - =tipo=: La API SIAR[fn:6] permite tener 4 tipos de registros: =Mensuales=, =Semanales=, =Diarios= y =Horarios=.
  - =n_est=: Con este argumento, la función es capaz de localizar el número seleccionado de estaciones más proximas a la ubicación dada, y obtener los datos individuales de cada una de ellas. Una vez obtenidos estos datos realiza una interpolación de distancia inversa ponderada (IDW) y entrega un solo resultado. Es importante añadir que la API SIAR tiene una limitación a la solicitud de registros que se le hace cada minuto, por lo que esta función cuenta con un comprobante para impedir que el usuario exceda este límite.
      
* Radiación en el plano horizontal
Una vez se ha calculado la geometría solar (sección ref:sec:geometria-solar) y se han procesado los datos meteorológicos (sección ref:sec:datos-meteorologicos), es necesario calcular la radiación en el plano horizontal. Para ello, =solaR2= cuenta con la función =calcG0= [ref:subsec:calcg0] la cual mediante las funciones =fCompD= [ref:subsec:fcompd] y =fCompI= [ref:subsec:fcompi] procesan los objetos de clase =Sol= y clase =Meteo= para dar un objeto de tipo =G0=.

Como se puede ver en la figura ref:fig:calcg0, =calcG0= funciona gracias a las siguientes funciones:
#+CAPTION: :label:fig:calcg0
#+ATTR_LATEX: :width \textwidth :height 0.5\textheight :options keepaspectratio
file:figuras/calcg0.pdf
- =fCompD=: La cual computa todas las componentes de la irradiación diaria en una superficie horizontal mediante regresiones entre los parámetros del índice de claridad y la fracción difusa.
  Para ello se pueden usar varias correlaciones dependiendo del tipo de datos:
  - Mensuales:
  #+begin_src R
  lat <- 37.2
  BTd <- fBTd(mode = 'prom')
  solD <- fSolD(lat, BTd)
  G0d <- c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,7.027,5.369,3.562,2.814,2.179) * 1000
  compD_page <- fCompD(sol = solD, G0d = G0d, corr = "Page")
  compD_page
  #+end_src
  #+begin_src R
  compD_lj <- fCompD(sol = solD, G0d = G0d, corr = "LJ")
  compD_lj
  #+end_src
  - Diarios:
  #+begin_src R
  G0d <- readSIAR(Lat = 40.40596822621351, Lon =-3.70038308516172,
		  inicio = '2024-07-15', final = '2024-08-01',
		  tipo = 'Diarios', n_est = 3)
  sol <- calcSol(lat, BTd = indexD(G0d))
  compD_cpr <- fCompD(sol = sol, G0d = G0d, corr = "CPR")
  compD_cpr
  #+end_src
  #+begin_src R
  compD_ekdd <- fCompD(sol = sol, G0d = G0d, corr = 'EKDd')
  compD_ekdd
  #+end_src
  #+begin_src R
  compD_climedd <- fCompD(sol = sol, G0d = G0d, corr = 'CLIMEDd')
  compD_climedd
  #+end_src
  También, se puede aportar una función de corrección propia.
  #+begin_src R
  f_corrd <- function(sol, G0d){
    ## Función CLIMEDd
      Kt <- Ktd(sol, G0d)
      Fd=(Kt<=0.13)*(0.952)+
      (Kt>0.13 & Kt<=0.8)*(0.868+1.335*Kt-5.782*Kt^2+3.721*Kt^3)+
	(Kt>0.8)*0.141
    return(data.table(Fd, Kt))
  }
  compD_user <- fCompD(sol = sol, G0d = G0d, corr = 'user', f = f_corrd)
  compD_user
  #+end_src
  Por último, si =G0d= ya contiene todos los componentes, se puede especifica que no haga ninguna corrección.
  #+begin_src R
  compD_none <- fCompD(sol = sol, G0d = compD_user, corr = 'none')
  compD_none
  #+end_src
- =fCompI=: calcula, en base a los valores de irradiación diaria, todas las componentes de irradiancia. Se vale de dos procedimientos en base al tipo de argumentos que toma:
  - =compD=: Si recibe un =data.table= resultado de =fCompD=, computa las relaciones entre las componentes de irradiancia e irradiación de las componentes de difusa y global, obteniendo con ellas un perfil de irradiancias [ref:sec:radiacion-superficies-inclinadas] (las irradiancias global y difusa salen de estas relaciones, mientras que la directa surge por diferencia entre las dos).
  #+begin_src R
  sol <- calcSol(lat = 37.2, BTd = fBTd(mode = 'prom'),
		 sample = 'hour', keep.night = FALSE)
  G0d <- c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,
	    7.027,5.369,3.562,2.814,2.179) * 1000
  compD <- fCompD(sol = sol, G0d = G0d, corr = 'CPR')
  compI <- fCompI(sol = sol, compD = compD)
  show(compI)
  #+end_src
  - =G0I=: Este argumento recibe datos de irradiancia, para después, poder aplicar las correcciones indicadas en el argumento =corr=.
  #+begin_src R
  G0I <- compI$G0
  compI_ekdh <- fCompI(sol = sol, G0I = G0I, corr = 'EKDh')
  show(compI_ekdh)
  #+end_src
  #+begin_src R
  compI_brl <- fCompI(sol = sol, G0I = G0I, corr = 'BRL')
  show(compI_brl)
  #+end_src
  #+begin_src R
  compI_climedh <- fCompI(sol = sol, G0I = G0I, corr = 'CLIMEDh')
  show(compI_climedh)
  #+end_src
  Como con =fCompD=, se puede añadir una función correctora propia.
  #+begin_src R
  f_corri <- function(sol, G0i){
    ## Función CLIMEDh
    Kt <- Kti(sol, G0i)
    Fd=(Kt<=0.21)*(0.995-0.081*Kt)+
      (Kt>0.21 & Kt<=0.76)*(0.724+2.738*Kt-8.32*Kt^2+4.967*Kt^3)+
      (Kt>0.76)*0.180
    return(data.table(Fd, Kt))
  }
  compI_user <- fCompI(sol = sol, G0I = G0I, corr = 'user', f = f_corri)
  show(compI_user)
  #+end_src
  Y además, se puede no añadir corrección.
  #+begin_src R
  G0I <- compI_user
  compI_none <- fCompI(sol = sol, G0I = G0I, corr = 'none')
  show(compI_none)
  #+end_src
  Por útlimo, esta función incluye un argumento extra, =filterG0= que cuando su valor es =TRUE=, elimina todos aquellos valores de irradiancia que son mayores que la irradiancia extra-atmosfércia (ya que es incoherente que la irradiancia terrestre sea mayor que la extra-terrestre)

Estas dos funciones, como se muestra en la figura ref:fig:calcg0, convergen en la función constructora =calcG0=, dando como resultado un objeto de clase =G0=. Este objeto muestra la media mensual de la irradiación diaria y la irradiación anual. A parte incluye los resultados de =fCompD= y =fCompI= y los objetos =Sol= y =Meteo= de los que parte.

Como argumento más importante está =modeRad=, el cual selecciona el tipo de datos que introduce el usuario en el argumento =dataRad=. Estos son:
- Medias mensuales.
  #+begin_src R
  G0dm <- c(2.766, 3.491, 4.494, 5.912, 6.989, 7.742, 7.919,
	    7.027, 5.369, 3.562, 2.814, 2.179) * 1000
  Ta <- c(10, 14.1, 15.6, 17.2, 19.3, 21.2,
	 28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
  prom <- data.table(G0dm, Ta) 
  g0_prom <- calcG0(lat, modeRad = 'prom', dataRad = prom)
  show(g0_prom)
  #+end_src
- Generación de secuencias diarias mediante matrices de transición de Markov.
  #+begin_src R
  g0_aguiar <- calcG0(lat, modeRad = 'aguiar', dataRad = prom)
  show(g0_aguiar)
  #+end_src
- Diarios.
  #+begin_src R
  bd <- g0_aguiar@G0D
  g0_bd <- calcG0(lat, modeRad = 'bd', dataRad = bd)
  show(g0_bd)
  #+end_src
- Intradiarios
  #+begin_src R
  bdI <- g0_aguiar@G0I
  g0_bdI <- calcG0(lat, modeRad = 'bdI', dataRad = bdI)
  show(g0_bdI)
  #+end_src

* Radiación efectiva en el plano del generador 
* Footnotes

[fn:1] Todas las funciones mencionadas en este punto, se encuentran en el apartado ref:subsec:utils-angles.

[fn:2] Cuando la hora solar verdadera excede los ángulos en los que amanece y anochece ($|\omega|>=|\omega_s|$), el Sol queda por debajo de la línea del horizonte, por lo que es de noche.

[fn:3] $\gamma_s=asin(cos(\theta_s))$.

[fn:4] Las funciones comentadas en este apartado, se recogen en la sección ref:subsec:meteoreaders

[fn:5] Pese a que este proyecto trate de "desligarse" del paquete =zoo=, sigue siendo un paquete muy extendido. Por lo que es interesante tener una función así para que los usuarios tengan una mayor flexibilidad.

[fn:6] La API (Interfaz de Programación de Aplicaciones) que se usa para la función =readSIAR= está proporcionada por la propia red SIAR cite:siar23.
