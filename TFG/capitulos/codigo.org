#+PROPERTY: header-args:R :dir . :session *R* :exports both :results output
\chapter{Desarrollo del código}
label:chap:desarrollo-codigo
En la figura [[fig:prod-solar2]], se muestra el proceso de cálculo que sigue el paquete a la hora de obtener la estimación de la producción del sistema fotovoltaico.
#+ATTR_LATEX: :height 0.43\textheight :width 0.8\textwidth :options keepaspectratio
#+CAPTION: Proceso de cálculo de las funciones de =solaR2=
#+NAME: fig:prod-solar2
[[file:figuras/procedure.pdf]]
A la hora de estimar la producción, el programa sigue los siguientes procesos[fn:1]:
* Geometría solar
label:sec:geometria-solar
Para calcular la geometría que definen las posiciones de la Tierra y el Sol, =solaR2= se vale de una función constructora, =calcSol=, la cual mediante las funciones =fSolD= y =fSolI= cálcula todos los ángulos y componentes que caracterizan la geometría solar.
#+CAPTION: Cálculo de la geometría solar mediante la función =calcSol=, la cual unifica las funciones =fSolD= y =fSolI= resultando en un objeto clase =Sol= el cual contiene toda la información geométrica necesaria para realizar las siguientes estimaciones. label:fig:calcSol
#+ATTR_LATEX: :height 0.5\textheight :width \textwidth :options keepaspectratio
[[file:figuras/calcSol.pdf]]

Como se puede ver en la figura ref:fig:calcSol, =calcSol= funcia gracias a las siguientes funciones:
- =fSolD=: la cual, a partir de la latitud (\(\phi\)), calcula la geometría a nivel diario, es decir, los ángulos y componentes que se pueden calcular en cada día independiente.
  Estas son:
  - Declinación (\(\delta\)): calculada a partir de la función =declination=.
  - Excentricidad (\(\epsilon_o\)): obtenida mediante la función =eccentricity=.
  - Ecuación del tiempo (\(EoT\)): obtenida mediante la función =eot=.
  - Ángulo del amanecer (\(\omega_s\)): calculada a partir de la función =sunrise=.
  - Irradiancia diaria extra-atmosférica (\(B_{0d}(0)\)): obtenida a paritr de la función =bo0d=.
#+begin_src R :exports none
  library(solaR2)
  library(zoo)
  library(httr2)
  library(jsonlite)
  setwd('TFG')
#+end_src

#+RESULTS:
#+begin_example
Cargando paquete requerido: data.table
data.table 1.15.4 using 6 threads (see ?getDTthreads).  Latest news: r-datatable.com
Cargando paquete requerido: lattice
Cargando paquete requerido: latticeExtra
Time Zone set to UTC.

Adjuntando el paquete: 'zoo'

The following objects are masked from 'package:data.table':

    yearmon, yearqtr

The following objects are masked from 'package:base':

    as.Date, as.Date.numeric
#+end_example

#+begin_src R 
lat <- 37.2
BTd <- fBTd(mode = 'prom')
solD <- fSolD(lat = lat, BTd = BTd)
show(solD)
#+end_src
  Tiene los siguientes argumentos:
  - =lat=: para introducir la latitud en grados.
  - =BTd=: para introducir la base temporal *diaria* sobre la que se harán los cálculos.
  - =method=: para elegir el método de cálculo. Se puede elegir entre: =michalsky=, =cooper=, =spencer= y =strous=
    #+begin_src R :results output graphics :file "figuras/codigo-fSolD.pdf" :width 8 :height 6
    BTd <- fBTd(mode = 'prom')
    solD_michalsky <- fSolD(lat, BTd, method = 'michalsky')
    solD_michalsky[, group := 'michalsky']
    solD_cooper <- fSolD(lat, BTd, method = 'cooper')
    solD_cooper[, group := 'cooper']
    solD_spencer <- fSolD(lat, BTd, method = 'spencer')
    solD_spencer[, group := 'spencer']
    solD_strous <- fSolD(lat, BTd, method = 'strous')
    solD_strous[, group := 'strous']
    solD_all <- rbind(solD_michalsky, solD_cooper,
		      solD_spencer, solD_strous)
    xyplot(eo + ws + Bo0d ~ Dates , solD_all,
	   groups = group, type = 'l', auto.key = TRUE,
	   par.settings = solaR.theme, scales = list(y = 'free'),
	   ylab = '', layout = c(1, 3))
    #+end_src
    #+ATTR_LATEX: :width 0.8\textwidth
    file:figuras/codigo-fSolD.pdf
- =fSolI=: toma los resultados obtenidos en =fSolD= y calcula la geometría a nivel intradiario, es decir, aquella que se puede calcular en unidades de tiempo menores a los días.
  Estas son:
  - La hora solar o tiempo solar verdadero (\(\omega\)): calculada a partir de la función =sunHour=.
  - Los momentos del día en los que es de noche (\(night\)): calculada a partir del resultado anterior y de el ángulo del amanecer (cálculada en =fSolD=)[fn:2].
  - El coseno del ángulo cenital solar (\(cos(\theta_{zs})\)): obtenida a partir de la función =zenith=.
  - La altura solar (\(\gamma_s\)): obtenida a partir del resultado anterior[fn:3].
  - El ángulo acimutal solar (\(\theta_{zs}\)): calculada mediante la función =azimuth=.
  - La irradiancia extra-atmosférica (\(B_0(0)\)): calculada mediante el coseno del ángulo cenital, la constante solar (\(B_0\)) y la excentridad (cálculada en =fSolD=) [ecuación ref:eq:irradianciaextra].
  Su argumento principal es =sample= con el cual se puede determinar el intervalo intradiario de cálculos.
#+begin_src R :results output graphics :file "figuras/codigo-solI.pdf" :width 8 :height 6
solD <- solD[1] #Computo solo un día a fin mejorar la visualización
solI <- fSolI(solD = solD, sample = 'min') 
xyplot(solI)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-solI.pdf
  Además, como los datos nocturnos aportan poco a los cálculos que atañen a este proyecto, =fSolI= presenta la posibilidad de eliminar estos datos con el argumento =keep.night=.
#+begin_src R :results graphics output :file "figuras/codigo-solInight.pdf" :width 8 :height 6
solI_nigth <- fSolI(solD = solD, sample = 'min', keep.night = FALSE)
xyplot(solI_nigth)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-solInight.pdf
  Aparte, en vez de identificar el intervalo intradiario (con el argumento =sample=), se puede dar directamente la base temporal intradiaria.
#+begin_src R :results graphics output :file "figuras/codigo-solIBTi.pdf" :width 8 :height 6
BTd <- solD$Dates
BTi <- fBTi(BTd, sample = 'min')
solI_BTi <- fSolI(solD, BTi = BTi, keep.night = FALSE)
xyplot(solI_BTi)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-solIBTi.pdf
  También, se puede indicar que no realice las correcciones de la ecuación del tiempo.
#+begin_src R :results output graphics :file "figuras/codigo-solIEoT.pdf" :width 8 :height 6
solI_EoT <- fSolI(solD = solD, BTi = BTi, EoT = FALSE)
xyplot(solI_EoT)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-solIEoT.pdf

Finalmente, estas dos funciones, como se muestra en la figura ref:fig:calcSol, convergen en la función =calcSol=, dando como resultado un objeto de clase =Sol=. Este objeto muestra un resumen de ambos elementos junto con la latitud de los cálculos. Los argumentos de =calcSol= son las argumentos de las funciones anteriores
#+begin_src R
sol <- calcSol(lat = lat, BTd = BTd, sample = 'hour')
show(sol)
#+end_src


* Datos meteorológicos
label:sec:datos-meteorologicos
Para el procesamiento de datos meteorologicos, =solaR2= provee una serie de funciones que son capaces de leer todo tipo de datos. Estos datos se procesan y se almacenan en un objeto de tipo =Meteo= tal y como se ve en la figura ref:fig:meteo. Estas funciones son:
#+CAPTION: Los datos meteorologicas se pueden leer mediante las funciones =readG0dm=, =readBD=, =dt2Meteo=, =zoo2Meteo= y =readSIAR= las cuales procesan estos datos y los almacenan en un objeto de clase =Meteo=. label:fig:meteo
#+ATTR_LATEX: :height 0.5\textheight :width \textwidth :options keepaspectratio 
file:figuras/meteo.pdf
- =readG0dm=: Esta función construye un objeto =Meteo= a partir de 12 valores de medias mensuales de irradiación.
  Como argumentos tiene:
  - =G0dm=: vector con medias mensuales de irradiación global horizontal.
  - =Ta=: vector con la temperatura ambiente.
  - =lat=: latitud en grados.
  - =year=: año de los datos. Por defecto presenta el año actual.
  - =source=: información de la fuente de los datos.
#+begin_src R :results graphics output :file "figuras/codigo-readg0dm.pdf" :width 8 :height 6
G0dm = c(2.766,3.491,4.494,5.912,6.989,7.742,
         7.919,7.027,5.369,3.562,2.814,2.179) * 1000;
Ta = c(10, 14.1, 15.6, 17.2, 19.3, 21.2,
       28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
BD <- readG0dm(G0dm = G0dm, Ta = Ta, lat = 37.2)
xyplot(BD)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-readg0dm.pdf
- =readBD=: Esta familia de funciones puede leer ficheros de datos y transformarlos en un objeto de clase =Meteo=. Se dividen en:
  - =readBDd=: Procesa datos meteorológicos de tipo diarios.
    Como argumentos tiene:
    - =file=: nombre del archivo que contiene los datos.
    - =lat=: latitud en grados.
    - =format=: formato de los datos de fechas.
    - =header=, =fill=, =dec=, =sep=: argumentos para [[https://search.r-project.org/CRAN/refmans/data.table/html/fread.html][=fread=]].
    - =dates.col=: nombre de la columna que contiene los datos de fechas. Por defecto es 'Dates'.
    - =ta.col=: nombre de la columna que contiene los datos de temperatura. Por defecto es 'Ta'.
    - =g0.col=: nombre de la columna que contiene los datos de irradiación. Por defecto es 'G0'.
    - =keep.cols=: si su valor es =TRUE=, mantiene las columnas que no sean importantes para el resto de operaciones.
  #+begin_src R :results graphics output :file "figuras/codigo-readBD.pdf" :width 12 :height 9
  ## Se utiliza un archivo alojado en el
  ## github del tutor de este proyecto 
  myURL <-"https://raw.githubusercontent.com/oscarperpinan/R/master/data/aranjuez.csv"
  download.file(myURL, 'data/aranjuez.csv', quiet = TRUE)
  BDd <- readBDd(file = 'data/aranjuez.csv', lat = lat,
		 format = '%Y-%m-%d', header = TRUE,
		 fill = TRUE, dec = '.', sep = ',', dates.col = '',
		 ta.col = 'TempAvg', g0.col = 'Radiation', keep.cols = TRUE)
  xyplot(BDd)
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-readBD.pdf
  - =readBDi=: Procesa datos meteorológicos de tipo intradiarios.
    Como argumentos tiene:
    - =file=: nombre del archivo que contiene los datos.
    - =lat=: latitud en grados.
    - =format=: formato de los datos de fechas.
    - =header=, =fill=, =dec=, =sep=: argumentos para [[https://search.r-project.org/CRAN/refmans/data.table/html/fread.html][=fread=]].
    - =dates.col=: nombre de la columna que contiene los datos de fechas y/o tiempos. Por defecto es 'Dates'.
    - =times.col=: nombre de la columna que contiene los datos de tiempos en caso de que =dates.col= no los incluyera.
    - =ta.col=: nombre de la columna que contiene los datos de temperatura. Por defecto es 'Ta'.
    - =g0.col=: nombre de la columna que contiene los datos de irradiancia. Por defecto es 'G0'.
    - =keep.cols=: si su valor es =TRUE=, mantiene las columnas que no sean importantes para el resto de operaciones.
  #+begin_src R :results graphics output :file "figuras/codigo-readBDi.pdf" :width 8 :height 6
  myURL <- "https://raw.githubusercontent.com/oscarperpinan/R/master/data/NREL-Hawaii.csv"
  download.file(myURL, 'data/NREL-Hawaii.csv', quiet = TRUE)
  BDi <- readBDi(file = 'data/NREL-Hawaii.csv', lat = 19,
		 format = "%d/%m/%Y %H:%M", header = TRUE,
		 fill = TRUE, dec = '.', sep = ',',
		 dates.col = 'DATE', times.col = 'HST',
		 ta.col = 'Air Temperature [deg C]',
		 g0.col = 'Global Horizontal [W/m^2]',
		 keep.cols = TRUE)
  xyplot(BDi)
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-readBDi.pdf
- =dt2Meteo=: Transforma un =data.table= o =data.frame= en un objeto de clase =Meteo=.
  Como argumentos tiene:
  - =file=: =data.table= que contiene los datos.
  - =lat=: latitud en grados.
  - =source=: información sobre la fuente de los datos.
  - =type=: tipo de datos. A elegir  entre =bdI= (intradiarios), =bd= (diarios) y =prom= (medias mensuales). Si no viene dado, lo calcula por su cuenta.
#+begin_src R :results graphics output :file "figuras/codigo-dt2meteo.pdf" :width 8 :height 6
data(helios)
names(helios) <- c('Dates', 'G0d', 'TempMax', 'TempMin')
helios_meteo <- dt2Meteo(file = helios, lat = 40, type = 'bd')
xyplot(helios_meteo)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-dt2meteo.pdf
- =zoo2Meteo=: Transforma un objeto de clase =zoo=[fn:4] en un objeto de clase =Meteo=.
  Como argumentos tiene:
  - =file=: =data.table= que contiene los datos.
  - =lat=: latitud en grados.
  - =source=: información sobre la fuente de los datos.
#+begin_src R
library(zoo)
bd_zoo <- read.csv.zoo('data/aranjuez.csv')
BD_zoo <- zoo2Meteo(file = bd_zoo, lat = 40)
show(BD_zoo)
#+end_src
- =readSIAR=: Esta función es capaz de extraer información de la red SIAR[fn:5] y transformarlo en un objeto de clase =Meteo=.
  Como argumentos tiene:
  - =Lon=: Longitud en grados.
  - =Lat=: Latitud en grados.
  - =inicio=: Primer día de los registros.
  - =final=: Último día de los registros.
  - =tipo=: La API SIAR[fn:6] permite tener 4 tipos de registros: =Mensuales=, =Semanales=, =Diarios= y =Horarios=.
  - =n_est=: Con este argumento, la función es capaz de localizar el número seleccionado de estaciones más proximas a la ubicación dada, y obtener los datos individuales de cada una de ellas. Una vez obtenidos estos datos realiza una interpolación de distancia inversa ponderada (IDW[fn:7]) y entrega un solo resultado. Es importante añadir que la API SIAR tiene una limitación a la solicitud de registros que se le hace cada minuto, por lo que esta función cuenta con un comprobante para impedir que el usuario exceda este límite.
#+begin_src R :results graphics :file "figuras/codigo-readsiar.pdf" :width 8 :height 6
library(httr2)
library(jsonlite)
bd_SIAR <- readSIAR(Lat = 40.40596822621351, Lon = -3.70038308516172,
		    ## Ubicación de la Escuela Técnica Superior
		    ## de Ingeniería y Diseño Industrial (ETSIDI)
		    inicio = '2023-09-01', final = '2024-08-01',
		    tipo = 'Mensuales', n_est = 3)
xyplot(bd_SIAR)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-readsiar.pdf
      
* Radiación en el plano horizontal
label:sec:radiacion-plano-horizontal
Una vez se ha calculado la geometría solar (sección ref:sec:geometria-solar) y se han procesado los datos meteorológicos (sección ref:sec:datos-meteorologicos), es necesario calcular la radiación en el plano horizontal. Para ello, =solaR2= cuenta con la función =calcG0= la cual mediante las funciones =fCompD= y =fCompI= procesan los objetos de clase =Sol= y clase =Meteo= para dar un objeto de tipo =G0=.

Como se puede ver en la figura ref:fig:calcg0, =calcG0= funciona gracias a las siguientes funciones:
#+CAPTION: Cálculo de la radiación incidente en el plano horizontal mediante la función =calcG0=, la cual procesa un objeto clase =Sol= y otro clase =Meteo= mediante las funciones =fCompD= y =fCompI= resultando en un objeto clase =G0=. :label:fig:calcg0
#+ATTR_LATEX: :width \textwidth :height 0.5\textheight :options keepaspectratio
file:figuras/calcg0.pdf
- =fCompD=: La cual calcula todas las componentes de la irradiación diaria en una superficie horizontal mediante regresiones entre los parámetros del índice de claridad y la fracción difusa.
  Tiene los siguientes argumentos:
  - =sol=: Un objeto de clase =Sol=.
  - =G0d=: Un objeto clase =Meteo= o un =data.table= con datos de irradiación diaria en una superficie horizontal.
  - =corr=: A elegir el tipo de correlación entre la fracción de difusa y el índice de claridad.
    Dependiendo del tipo de datos:
    - Mensuales:
    #+begin_src R :results graphics output :file "figuras/codigo-fcompdmes.pdf" :width 8 :height 6
    lat <- 37.2
    BTd <- fBTd(mode = 'prom')
    solD <- fSolD(lat, BTd)
    G0d <- c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,7.027,5.369,3.562,2.814,2.179) * 1000
    compD_page <- fCompD(sol = solD, G0d = G0d, corr = "Page")
    compD_page[, group := 'page']
    compD_lj <- fCompD(sol = solD, G0d = G0d, corr = "LJ")
    compD_lj[, group := 'lj']
    compD_dia <- rbind(compD_page, compD_lj)
    xyplot(Fd + D0d + B0d ~ Dates, compD_dia,
	   groups = group, type = 'l', auto.key = TRUE,
	   par.settings = solaR.theme, scales = list(y = 'free'),
	   ylab = '', layout = c(1, 3))

    #+end_src
    #+ATTR_LATEX: :width 0.8\textwidth
    file:figuras/codigo-fcompdmes.pdf
    - Diarios:
    #+begin_src R :results graphics output :file "figuras/codigo-fcompddia.pdf" :width 8 :height 6 
    G0d <- readSIAR(Lat = 40.40596822621351, Lon =-3.70038308516172,
		    inicio = '2024-07-15', final = '2024-08-01',
		    tipo = 'Diarios', n_est = 3)
    sol <- calcSol(lat, BTd = indexD(G0d))
    compD_cpr <- fCompD(sol = sol, G0d = G0d, corr = "CPR")
    compD_cpr[, group := 'cpr']
    compD_ekdd <- fCompD(sol = sol, G0d = G0d, corr = 'EKDd')
    compD_ekdd[, group := 'ekdd']
    compD_climedd <- fCompD(sol = sol, G0d = G0d, corr = 'CLIMEDd')
    compD_climedd[, group := 'climedd']
    compD_mes <- rbind(compD_cpr, compD_ekdd, compD_climedd)
    xyplot(Fd + D0d + B0d ~ Dates, compD_mes,
	   groups = group, type = 'l',auto.key = TRUE,
	   par.settings = solaR.theme, scales = list(y = 'free'),
	   ylab = '', layout = c(1, 3))
    #+end_src
    #+ATTR_LATEX: :width 0.8\textwidth
    file:figuras/codigo-fcompddia.pdf
    También, se puede aportar una función de correlación propia con el argumento =f=.
    #+begin_src R :results graphics output :file "figuras/codigo-fcompduser.pdf" :width 8 :height 6
    f_corrd <- function(sol, G0d){
      ## Función CLIMEDd
	Kt <- Ktd(sol, G0d)
	Fd=(Kt<=0.13)*(0.952)+
	(Kt>0.13 & Kt<=0.8)*(0.868+1.335*Kt-5.782*Kt^2+3.721*Kt^3)+
	  (Kt>0.8)*0.141
      return(data.table(Fd, Kt))
    }
    compD_user <- fCompD(sol = sol, G0d = G0d, corr = 'user', f = f_corrd)
    xyplot(compD_user)
    #+end_src
    #+ATTR_LATEX: :width 0.8\textwidth
    file:figuras/codigo-fcompduser.pdf
    Por último, si =G0d= ya contiene todos los componentes, se puede especifica que no haga ninguna correlación.
    #+begin_src R
    compD_none <- fCompD(sol = sol, G0d = compD_user, corr = 'none')
    compD_none
    #+end_src
- =fCompI=: calcula, en base a los valores de irradiación diaria, todas las componentes de irradiancia. Se vale de dos procedimientos en base al tipo de argumentos que toma:
  - =compD=: Si recibe un =data.table= resultado de =fCompD=, calcula las relaciones entre las componentes de irradiancia e irradiación de las componentes de difusa y global, obteniendo con ellas un perfil de irradiancias [ref:sec:radiacion-superficies-inclinadas] (las irradiancias global y difusa salen de estas relaciones, mientras que la directa surge por diferencia entre las dos).
  #+begin_src R :results graphics output :file "figuras/codigo-fcompicompd.pdf" :width 8 :height 6
  sol <- calcSol(lat = 37.2, BTd = fBTd(mode = 'prom'),
		 sample = 'hour', keep.night = FALSE)
  G0d <- c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,
	    7.027,5.369,3.562,2.814,2.179) * 1000
  compD <- fCompD(sol = sol, G0d = G0d, corr = 'CPR')
  compI <- fCompI(sol = sol, compD = compD)
  xyplot(compI)
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-fcompicompd.pdf
  - =G0I=: Este argumento recibe datos de irradiancia, para después, poder aplicar las correcciones indicadas en el argumento =corr=.
  #+begin_src R :results graphics output :file "figuras/codigo-compicorr.pdf" :width 8 :height 6
  G0I <- compI$G0
  compI_ekdh <- fCompI(sol = sol, G0I = G0I, corr = 'EKDh')
  compI_ekdh[, group := 'ekdh']
  compI_brl <- fCompI(sol = sol, G0I = G0I, corr = 'BRL')
  compI_brl[, group := 'brl']
  compI_climedh <- fCompI(sol = sol, G0I = G0I, corr = 'CLIMEDh')
  compI_climedh[, group := 'climedh']
  compI_all <- rbind(compI_ekdh, compI_ekdh, compI_climedh)
  xyplot(Fd+ D0 +B0 ~ Dates, compI_all,
	 groups= group, type = 'l',auto.key= TRUE,
	 par.settings= solaR.theme,scales =list(y = 'free'),
	 ylab = '', layout= c(1,3))
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  Como con =fCompD=, se puede añadir una función correctora propia.
  #+begin_src R
  f_corri <- function(sol, G0i){
    ## Función CLIMEDh
    Kt <- Kti(sol, G0i)
    Fd=(Kt<=0.21)*(0.995-0.081*Kt)+
      (Kt>0.21 & Kt<=0.76)*(0.724+2.738*Kt-8.32*Kt^2+4.967*Kt^3)+
      (Kt>0.76)*0.180
    return(data.table(Fd, Kt))
  }
  compI_user <- fCompI(sol = sol, G0I = G0I, corr = 'user', f = f_corri)
  show(compI_user)
  #+end_src
  Y además, se puede no añadir correlación.
  #+begin_src R
  G0I <- compI_user
  compI_none <- fCompI(sol = sol, G0I = G0I, corr = 'none')
  show(compI_none)
  #+end_src
  Por útlimo, esta función incluye un argumento extra, =filterG0= que cuando su valor es =TRUE=, elimina todos aquellos valores de irradiancia que son mayores que la irradiancia extra-atmosfércia (ya que es incoherente que la irradiancia terrestre sea mayor que la extra-terrestre)

Estas dos funciones, como se muestra en la figura ref:fig:calcg0, convergen en la función constructora =calcG0=, dando como resultado un objeto de clase =G0=. Este objeto muestra la media mensual de la irradiación diaria y la irradiación anual. Aparte, incluye los resultados de =fCompD= y =fCompI= y los objetos =Sol= y =Meteo= de los que parte.

Como argumento más importante está =modeRad=, el cual selecciona el tipo de datos que introduce el usuario en el argumento =dataRad=. Estos son:
- Medias mensuales.
  #+begin_src R
  G0dm <- c(2.766, 3.491, 4.494, 5.912, 6.989, 7.742, 7.919,
	    7.027, 5.369, 3.562, 2.814, 2.179) * 1000
  Ta <- c(10, 14.1, 15.6, 17.2, 19.3, 21.2,
	 28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
  prom <- data.table(G0dm, Ta) 
  g0_prom <- calcG0(lat, modeRad = 'prom', dataRad = prom)
  show(g0_prom)
  #+end_src
- Generación de secuencias diarias mediante matrices de transición de Markov.
  #+begin_src R
  g0_aguiar <- calcG0(lat, modeRad = 'aguiar', dataRad = prom)
  show(g0_aguiar)
  #+end_src
- Diarios.
  #+begin_src R
  bd <- as.data.tableD(g0_aguiar)
  g0_bd <- calcG0(lat, modeRad = 'bd', dataRad = bd)
  show(g0_bd)
  #+end_src
- Intradiarios
  #+begin_src R :results graphics output :file "figuras/codigo-calcg0.pdf" :width 8 :height 6
  bdI <- as.data.tableI(g0_aguiar)
  g0_bdI <- calcG0(lat, modeRad = 'bdI', dataRad = bdI)
  xyplot(g0_bdI)
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-calcg0.pdf

* Radiación efectiva en el plano del generador
label:sec:radiacion-efectiva-plano-generador
Teniendo la radiación incidente en plano horizontal (sección ref:sec:radiacion-plano-horizontal), se puede calcular la radiación efectiva incidente en el plano del generador. Para ello, =solaR2= cuenta con la función =calcGef= la cual mediante las funciones =fInclin= y =calcShd= procesa un objeto de clase =G0= para obtener un objeto =Gef=.

Como se puede ver en la figura ref:fig:calcgef, =calcGef= funciona gracias a las siguientes funciones:
#+CAPTION: Cálculo de la radiación efectiva incidente en el plano del generador mediante la función =calcGef=, la cual emplea la función =fInclin= para el computo de las componentes efectivas, la función =fTheta= que provee a la función anterior los ángulos necesarios para su computo y la función =calcShd= que reprocesa el objeto de clase =Gef= resultante, añadiendole el efecto de las sombras producidas entres módulos. label:fig:calcgef
#+ATTR_LATEX: :width \textwidth :height 0.5\textheight :options keepaspectratio
file:figuras/calcgef.pdf
- =fTheta=: la cual, partiendo del ángulo de inclinación (\(\beta\)) y la orientación (\(\alpha\)), calcula el ángulo de inclinación en cada instante (\(\beta\)), el ángulo azimutal (\(\psi_s\)) y el coseno del ángulo de incidencia  de la radiación solar en la superficie (\(cos(\theta_s)\)).
  Como principal argumento tiene =modeTrk=, el cual determina el sistema de seguimiento que tiene el sistema:
  - =fixed=: para sistemas estáticos.
  #+begin_src R :results graphics output :file "figuras/codigo-fthetafixed.pdf" :width 8 :height 6
  BTd <- fBTd(mode = 'serie')[1:10]
  sol <- calcSol(lat, BTd = BTd, keep.night = FALSE)
  beta <- lat - 10
  alpha <- 0
  angGen_fixed <- fTheta(sol = sol, beta = beta, alpha = alpha,
			 modeTrk = 'fixed')
  xyplot(angGen_fixed)
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-fthetafixed.pdf
  - =two=: para sistemas de seguimiento de doble eje.
  #+begin_src R :results graphics output :file "figuras/codigo-fthetatwo.pdf" :width 8 :height 6
  angGen_two <- fTheta(sol = sol, beta = beta, alpha = alpha,
		       modeTrk = 'two')
  xyplot(angGen_two)
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-fthetatwo.pdf
  - =horiz=: para sistemas de seguimiento horizontal Norte-Sur.
  #+begin_src R :results graphics output :file "figuras/codigo-fthetahoriz.pdf" :width 8 :height 6 
  angGen_horiz <- fTheta(sol = sol, beta = beta, alpha = alpha,
			 modeTrk = 'horiz')
  xyplot(angGen_horiz)
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-fthetahoriz.pdf
  También, tiene un argumento =BT= que indica cuando se usa la técnica de backtracking para un sistema horizontal Norte-Sur. Para funcionar, necesita de los argumentos =struct=, el cual presenta una lista con la altura de los módulos, y =dist=, el cual presenta un =data.frame= (o =data.table=) con la distancia que separa los módulos en la dirección Este-Oeste.
  #+begin_src R :results graphics output :file "figuras/codigo-fthetabt.pdf" :width 8 :height 6
  struct <- list(L = 1)
  distances <- data.table(Lew = 2)
  angGen_BT <- fTheta(sol = sol, beta = beta, alpha = alpha,
		      modeTrk = 'horiz', BT = TRUE,
		      struct = struct, dist = distances)
  xyplot(angGen_BT)
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-fthetabt.pdf
- =fInclin=: la cual, partiendo del resultado de =fTheta= y de un objeto de clase =G0=, cálcula la irradiancia solar incidente en una superficie inclinada junto con los efectos del ángulo de incidencia y la suciedad para obtener la irradiancia efectiva.
  Como argumentos principales están:
  - =iS=: permite seleccionar entre 4 valores del 1 al 4 correspondientes al grado de suciedad del módulo. Siendo 1 limpio y 4 alto y basandose en los valores de la tabla ref:tab:coef-perd calcula la irradiancia efectiva. Por defecto tiene valor 2 (grado de suciedad bajo).
  #+begin_src R :results graphics output :file "figuras/codigo-finclinis.pdf" :width 8 :height 6
  compI <- calcG0(lat, modeRad = 'bd', dataRad = bd[1:31], keep.night = FALSE)
  sol <- calcSol(lat, BTi = indexI(compI))
  angGen <- fTheta(sol = sol, beta = beta, alpha = alpha)
  inclin_limpio <- fInclin(compI = compI, angGen = angGen, iS = 1)
  inclin_limpio[, group := 'is = 1']
  inclin_sucio <- fInclin(compI = compI, angGen = angGen, iS = 4)
  inclin_sucio[, group := 'is = 4']
  inclin_is <- rbind(inclin_limpio, inclin_sucio)
  xyplot(Gef + Def + Bef + Ref ~ Dates, inclin_is,
	 groups = group, type = 'l', auto.key = TRUE,
	 par.settings = solaR.theme, scales = list(y = 'free'),
	 ylab = '', layout = c(2, 2))
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-finclinis.pdf
  - =alb= Correspondiente al coeficiente de reflexión del terreno para la irradiancia de albedo. Por defecto tiene un valor de 0,2 (valor aceptable para un terreno normal).
  #+begin_src R :results graphics output :file "figuras/codigo-finclinalb.pdf" :width 8 :height 6
  inclin_alb0 <- fInclin(compI = compI, angGen = angGen, alb = 0)
  inclin_alb0[, group := 'alb = 0']
  inclin_alb1 <- fInclin(compI = compI, angGen = angGen, alb = 1)
  inclin_alb1[, group := 'alb = 1']
  inclin_alb <- rbind(inclin_alb0, inclin_alb1)
  xyplot(Gef + Def + Bef + Ref ~ Dates, inclin_alb,
	 groups = group, type = 'l', auto.key = TRUE,
	 par.settings = solaR.theme, scales = list(y = 'free'),
	 ylab = '', layout = c(2, 2))
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-finclinalb.pdf
  Además, cuenta con dos argumentos adicionales, =horizBright=, el cual, cuando su valor es =TRUE= (el que tiene por defecto), realiza una corrección de la radiación difusa cite:REINDL19909, y =HCPV=, es el acrónimo de *High Concentration PV system*[fn:8] (sistema fotovoltaico de alta concentración) que cuando su valor es =TRUE= (por defecto está puesto en =FALSE=), anula los valores de radiación difusa y de albedo.
  #+begin_src R
  inclin_horizBright <- fInclin(compI = compI, angGen = angGen,
				horizBright = FALSE)
  summary(inclin_horizBright)
  #+end_src
  #+begin_src R
  inclin_HCPV <- fInclin(compI = compI, angGen = angGen,
			 HCPV = TRUE)
  summary(inclin_HCPV)
  #+end_src

Finalmente, esta función le otorga estos datos a la función =calcGef= para que produzca un objeto de clase =Gef= como resultado. Esta función tiene como argumentos principales los mismos que los que tiene =calcG0= ref:sec:radiacion-plano-horizontal, es decir, =modeRad= y =dataRad=. Y además, como es lógico, con todos los argumentos mencionados con anterioridad en =fTheta= y =fInclin=.
#+begin_src R
gef_prom <- calcGef(lat = lat, modeTrk = 'two', modeRad = 'prom',
                    dataRad = prom,
                    beta = lat-10, alpha = 0,
                    iS = 2, alb = 0.2,
                    horizBright = TRUE, HCPV = FALSE)
show(gef_prom)
#+end_src
Sin embargo, como argumento importante está =modeShd=, el cual permite incluir el efecto de las sombras entre módulos al objeto =Gef= mediante el uso de la función =calcShd=. Esta opción añade las variables =Gef0=, =Def0= y =Bef0= las cuales son las componentes de radiación efectiva previas a aplicar el efecto de las sombras con el fin de poder comparar.
#+begin_src R
struct <- list(W=23.11, L=9.8, Nrow=2, Ncol=8)
distances <- data.table(Lew=40, Lns=30, H=0)
gef_shd <- calcShd(radEf = gef_prom, modeShd = 'prom',
                   struct = struct, distances = distances)
show(gef_shd)
#+end_src
#+begin_src R
gef_shd2 <- calcGef(lat = lat, modeTrk = 'two', dataRad = prom,
                    modeShd = 'prom', struct = struct, distances = distances)
show(gef_shd2)
#+end_src
El argumento =modeShd= puede ser de distintas maneras:
- =area=: el efecto de las sombras se calcula como una reducción proporcional de las irradiancias difusa circunsolar y directa.
#+begin_src R
gef_shdarea <- calcGef(lat, modeTrk = 'two', dataRad = prom,
                       modeShd = 'area',
                       struct = struct, distances = distances)
show(gef_shdarea)
#+end_src
- =prom=: cuando =modeTrk= es =two=, se puede calcular el efecto de las sombras de un seguidor promedio.
#+begin_src R
gef_shdprom <- calcGef(lat, modeTrk = 'two', dataRad = prom,
                       modeShd = c('area', 'prom'),
                       struct = struct, distances = distances)
show(gef_shdprom)
#+end_src
- =bt=: cuando =modeTrk= es =horiz=, se puede calcular el efecto del /backtracking/ en las sombras.
#+begin_src R
gef_shdhoriz <- calcGef(lat, modeTrk = 'horiz', dataRad = prom,
                        modeShd = 'area',
                        struct = struct, distances = distances)
show(gef_shdhoriz)
#+end_src
#+begin_src R :results graphics output :file "figuras/codigo-gef.pdf" :width 8 :height 6 
gef_shdbt <- calcGef(lat, modeTrk = 'horiz', dataRad = prom,
                        modeShd = c('area', 'bt'),
                        struct = struct, distances = distances)
xyplot(gef_shdbt)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-gef.pdf
* Producción eléctrica de un SFCR
label:produccion-electrica-sfcr
Con la radiación efectiva, se puede estimar la producción eléctrica que va a tener un sistema fotovoltaico conectado a red. Esta estimación, se puede calcular mediante la función =prodGCPV= la cual mediante la función =fProd= procesa un objeto de clase =Gef= y obtiene un objeto =ProdGCPV=.

Como se puede ver en la figura ref:fig:prodgcpv, =prodGCPV= funciona gracias a la siguiente función:
#+CAPTION: Estimación de la producción eléctrica de un SFCR mediante la función =prodGCPV=, la cual emplea la función =fProd= para el computo de la potencia a la entrada (\(P_{DC}\)), a la salida (\(P_{AC}\)) y el rendimiento (\(\eta_{inv}\)) del inversor. label:fig:prodgcpv
#+ATTR_LATEX: :width 0.8\textwidth :height \textheight :options keepaspectratio
file:figuras/prodgcpv.pdf
- =fProd=: simula el comportamiento de un sistema fotovoltaico conectado a red bajo diferentes condiciones de temperatura e irradiancia. Tiene los siguientes argumentos:
  - =inclin=: puede ser tanto un objeto de clase =Gef= como un =data.frame= (o =data.table=). Sin embargo, si es un =data.frame=, debe contener como mínimo una columna para =Gef= y otra para =Ta=
  - =module=: una lista de valores numéricos con la información sobre el módulo fotovoltaico:
    - =Vocn=: tensión de circuito abierto en STC (\(V_{oc}^*\))(condiciones estandar de médida). Por defecto, tiene un valor de \(57.2V\).
    - =Iscn=: corriente de cortocircuito en STC (\(I_{sc}^*\)). Por defecto, tiene un valor de \(4.7A\).
    - =Vmn=: tensión en el punto de máxima potencia en STC (\(I_{MPP}^*\)). Por defecto, tiene un valor de \(46.08V\).
    - =Imn=: corriente de cortocircuito en STC (\(I_{MPP}^*\)). Por defecto, tiene un valor de \(4.35A\)).
    - =Ncs=: número de células en serie dentro del módulo. Por defecto, tiene un valor de 96.
    - =Ncp=: número de células en paralelo dentro del módulo. Por defecto, tiene un valor de 1.
    - =CoefVT=: coeficiente de disminución de la tensión  de cada célula con la temperatura (\(dV_{oc}/dT_c\)). Por defecto, tiene un valor de \(-0.0023 V/^\circ C\).
    - =TONC=: temperatura de operación nominal de célula (\(TONC\)). Por defecto, tiene un valor de \(47^\circ C\).
  - =generator=: lista de valores numéricos con la información sobre el generador:
    - =Nms=: número de módulos en serie. Por defecto, tiene un valor de 12.
    - =Nmp=: número de módulos en paralelo. Por defecto, tiene un valor de 11.
  - =inverter=: lista de valores númericos con la información del inversor DC/AC.
    - =Ki=: coeficientes de la curva de eficiencia del inversor. Se puede presentar en un vector de 3 valores (por defecto, =c(0.01, 0.025, 0.05)=) o una matriz de 9 valores (si tiene dependencia del voltage).
    - =Pinv=: potencia nominal del inversor. Por defecto, tiene un valor de \(25000 W\).
    - =Vmin=: mínima tensión del rango MPP del inversor. Por defecto, tiene un valor de \(420V\).
    - =Vmax=: máxima tensión del rango MPP del inversor. Por defecto, tiene un valor de \(750V\).
    - =Gumb=: irradiancia umbral de funcionamienot del inversor. Por defecto, tiene un valor de \(20W/m^2\).
  - =effSys=: una lista de valores numéricos con la información sobre las pérdidas del sistema.
    - =ModQual=: tolerancia media del set de módulos (\(\%\)). Por defecto, tiene un valor de 3.
    - =ModDisp=: pérdidas por dispersión en los módulos (\(\%\)). Por defecto, tiene un valor de 2.
    - =OhmDC=: pérdidas por efecto Joule en el cableado de DC (\(\%\)). Por defecto, tiene un valor de 1.5.
    - =OhmAC=: pérdidas por efecto Joule en el cableado de AC (\(\%\)). Por defecto, tiene un valor de 1.5.
    - =MPP=: error promedio del algoritmo de búsqueda del MPP del inversor (\(\%\)). Por defecto, tiene un valor de 1.
    - =TrafoMT=: pérdidas por el transformador MT (\(\%\)). Por defecto, tiene un valor de 1.
    - =Disp=: pérdidas por las paradas del sistema (\(\%\)). Por defecto, tiene un valor de 0.5.
#+begin_src R
inclin <- calcGef(lat, dataRad = prom, keep.night = FALSE)
module <- list(Vocn=51.91, Iscn=14.07, Vmn=43.76, Imn=13.03,
               Ncs=24, Ncp=6, CoefVT=0.0049, TONC=45)
generator <- list(Nms=22, Nmp=130)
inverter <- list(Ki=c(0.002, 0.005, 0.008), Pinv=1.5e6,
                 Vmin=822, Vmax=1300, Gumb=20)
effSys <- list(ModQual=3, ModDisp=2, OhmDC=1.5, OhmAC=1.5,
               MPP=1, TrafoMT=1, Disp=0.5)
prod <- fProd(inclin = inclin, module = module,
              generator = generator, inverter = inverter,
              effSys = effSys)
show(prod)
#+end_src

Esta función brinda estos datos a la función =prodGCPV= para que produzca un objeto de clase =ProdGCPV= como resultado. Esta función tiene como argumentos principales los mismo que =calcGef=, ya que parte de un objeto tipo =Gef=, y los argumentos de la función =fProd=.
#+begin_src R
prodFixed <- prodGCPV(lat, modeTrk = 'fixed', dataRad = prom)
show(prodFixed)
#+end_src
#+begin_src R
prod2x <- prodGCPV(lat, modeTrk = 'two', dataRad = prom)
show(prod2x)
#+end_src
#+begin_src R :results graphics output :file "figuras/codigo-prodgcpv.pdf" :width 8 :height 6
prodHoriz <- prodGCPV(lat, modeTrk = 'horiz', dataRad = prom)
xyplot(prodHoriz)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-prodgcpv.pdf

* Producción eléctrica de un SFB
De igual forma que en el apartado anterior, se puede estimar la producción eléctrica de un sistema fotovoltaico de bombeo.

Como se puede ver en la figura ref:fig:prodpvps, =prodPVPS= funciona gracias a la siguiente función:
#+CAPTION: Estimación de la producción eléctrica de un SFB mediante la función =prodPVPS=, la cual emplea la función =fPump= para el computo del rendimiento de las diferentes parte de una bomba centrífuga alimentada por un convertidor de frecuencia. label:fig:prodpvps
#+ATTR_LATEX: :width 0.8\textwidth :height 0.5\textheight :options keepaspectratio
file:figuras/prodpvps.pdf
- =fPump=: calcula el rendimiento de las diferentes partes de una bomba centrífuga alimentada por un convertidor de frecuencia siguiendo las leyes de afinidad. Tiene solo dos argumentos:
  - =pump=: lista que contiene los parametros de la bomba que va a ser simulada. Puede ser una fila de =pumpCoef=:
    #+begin_src R
      CoefSP8A44 <- pumpCoef[Qn == 8 & stages == 44]
      show(CoefSP8A44)
    #+end_src
  - =H=: el salto manometrico total.
  #+begin_src R
    fSP8A44 <- fPump(pump = CoefSP8A44, H = 40)
  #+end_src
  Obtiene como resultado los siguientes valores y funciones:
  - =lim=: rango de valores de la potencia eléctrica de salida.
    #+begin_src R
      show(fSP8A44$lim)
    #+end_src
  - =fQ=: función que relaciona el caudal con la potencia eléctrica.
    #+begin_src R
      show(fSP8A44$fQ)
    #+end_src
  - =fPb=: función que relaciona la potencia del eje de la bomba con la potencia eléctrica del motor.
    #+begin_src R
      show(fSP8A44$fPb)
    #+end_src
  - =fPh=: función que relaciona la potencia hidráulica con la potencia eléctrica del motor.
    #+begin_src R
      show(fSP8A44$fPh)
    #+end_src
  - =fFreq=: función que relaciona la frecuencia con la potencia eléctrica del motor.
    #+begin_src R
      show(fSP8A44$fFreq)
    #+end_src
  Se pueden realizar operaciones con este objeto:
  #+begin_src R
    SP8A44 = with(fSP8A44,{
      Pac = seq(lim[1],lim[2],l=10)
      Pb = fPb(Pac)
      etam = Pb/Pac
      Ph = fPh(Pac)
      etab = Ph/Pb
      f = fFreq(Pac)
      Q = fQ(Pac)
      result = data.table(Q,Pac,Pb,Ph,etam,etab,f)})
    show(SP8A44)
  #+end_src
  Está función entrega todos estos resultados a =prodPVPS= la cual calcula los resultados en base a la potencia del generador a simular, y devuleve un objeto de clase =ProdPVPS=.
  #+begin_src R :results graphics output :file "figuras/codigo-prodpvps.pdf" :width 8 :height 6
  prodsfb <- prodPVPS(lat, modeTrk = 'fixed', dataRad = prom,
		      pump = CoefSP8A44, H = 40, Pg = SP8A44$Pac[10])
  xyplot(prodsfb)
  #+end_src
  #+ATTR_LATEX: :width 0.8\textwidth
  file:figuras/codigo-prodpvps.pdf
* Optimización de distancias
label:optimizacion-distancias
Por último, el paquete =solaR2= contiene una función que permite calcular un conjunto de combinaciones de distancias entre los elementos de un sistema fotovoltaico conectado a red, con el fin de que el usuario posteriormente pueda optar cual es la opción mas rentable en base a los precios del cableado y de la ocupación del terreno.

Esta función es =optimShd=, la cual en base a una resolución (determinada por el argumento =res=, el cual, indica el incremento de la secuencia de distancias) obtiene la producción de cada combinación y la plasma en un objeto de clase =Shade=.
#+begin_src R :results graphics output :file "figuras/codigo-optimshd2x.pdf" :width 8 :height 6
struct2x <- list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 3)
dist2x <- list(Lew = c(30, 45), Lns = c(20, 40))
ShdM2x <- optimShd(lat, dataRad = prom, modeTrk = 'two',
		   modeShd = c('area', 'prom'),
		   distances = dist2x, struct = struct2x,
		   res = 5,
                   prog = FALSE) #Se quita la barra de progreso
shadeplot(ShdM2x)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-optimshd2x.pdf
#+begin_src R 
structHoriz = list(L = 4.83)
distHoriz = list(Lew = structHoriz$L * c(2,5))
Shd12HorizBT <- optimShd(lat = lat, dataRad = prom,
			 modeTrk = 'horiz',
			 betaLim = 60,
			 distances = distHoriz, res = 2,
			 struct = structHoriz,
			 modeShd = 'bt',
			 prog = FALSE) #Se quita la barra de progreso
show(Shd12HorizBT)
#+end_src
#+begin_src R :results graphics outpur :file "figuras/codigo-optimshdfixed.pdf" :width 8 :height 6
structFixed = list(L = 5)
distFixed = list(D = structFixed$L*c(1,3))
Shd12Fixed <- optimShd(lat = lat, dataRad = prom,
		       modeTrk = 'fixed',
		       distances = distFixed, res = 2,
		       struct = structFixed,
		       modeShd = 'area',
		       prog = FALSE) #Se quita la barra de progreso
shadeplot(Shd12Fixed)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-optimshdfixed.pdf


* Aspectos técnicos de la elaboración de un paquete en R
label:sec:aspectos-tecnicos
** Estructura básica del paquete
label:subsec:estructura-paquete
En la creación de un paquete en =R=, la estructura de los archivos es clave para asegurar un desarrollo organizado y que =R= pueda interactuar correctamente con el código y  los datos. Los paquetes de R son esencialmente un conjunto de archivos organizados en un directorio específio. El contenido mínimo requerido incluye:
- Un archivo *DESCRIPTION*, que proporciona la información esencial del paquete.
- Un archivo *NAMESPACE*, que controla qué funciones y objetos son visibles fuera del paquete.
- Subdirectoriso como =R/= y =man/=:
  - =R/=: Contiene los archivos de codigo =.R=, que son las funciones, clases y métodos definidos en el paquete.
  - =man/=: Contiene las páginas de ayuda y documentación para las funciones, métodos y clases del paqeute.

La estructura básica de un paquete puede generarse fácilmente utilizando la función =package.skeleton()=, que crea los archivos y carpetas necesarios para empezar a trabajar en el desarrollo.

** DESCRIPTION
label:subsec:description
El fichero *DESCRIPTION* es fundamental, ya que incluye la información descriptiva y técnica del paquete, como el nombre, la versión, los autores y las dependencias. Un ejemplo típico de este archivo es el siguiente:
#+begin_export latex
\begin{examplebox}
#+end_export
#+begin_example
     Package: pkgname
     Version: 0.5-1
     Date: 2004-01-01
     Title: My First Collection of Functions
     Authors@R: c(person("Joe", "Developer", role = c("aut", "cre"),
                          email = "Joe.Developer@some.domain.net"),
                   person("Pat", "Developer", role = "aut"),
                   person("A.", "User", role = "ctb",
     	             email = "A.User@whereever.net"))
     Author: Joe Developer and Pat Developer, with contributions from A. User
     Maintainer: Joe Developer <Joe.Developer@some.domain.net>
     Depends: R (>= 1.8.0), nlme
     Suggests: MASS
     Description: A short (one paragraph) description of what
       the package does and why it may be useful.
     License: GPL (>= 2)
     URL: http://www.r-project.org, http://www.another.url
#+end_example
#+begin_export latex
\end{examplebox}
#+end_export
Los campos principales de este archivo son:
- *Package*: Nombre del paquete.
- *Version*: Versión del paquete. Generalmente sigue un esquema de numeración semántica (=major.minor-patch=)[fn:9].
- *Title*: Un título breve pero descriptivo de lo que hace el paquete.
- *Authors@R*: Especifica el o los autores con sus respectivos roles, como "aut" (autor) y "cre" (creador principal).
- *Maintainer*: Persona responsable del mantenimiento del paquete, con su correo electrónico.
- *Depends*: Lista de dependencias, es decir, otros paquetes de los que depende el correcto funcionamiento del paquete.
- *Suggests*: Lista de paqeute que no son obligatorios, pero que pueden ser útiles.
- *Description*: Una breve descripción del propósito del paquete.
- *License:* Tipo de licencia bajo la cual se distribuye el paquete (GPL, MIT, etc.).

Este archivo es crucial para que los usuarios y el sistema =R= identifiquen las características y requisitos del paquete
** NAMESPACE
label:subsec:namespace
El archivo *NAMESPACE* es el encargado de gestionar el espacio de nombres del paquete, permitiendo definir qué funciones y objetos serán visibles (exportados) y cuáles se mantendrán internos. Además, es útil para definir qué funciones o métodos de otros paquetes serán importados para us uso dentro del paquete.

=R= usa un sistema de gestión de *espacio de nombres* que permite al autor del paquete especificar:
- Las *variables* del paquete que se *exportan* (y son, por tanto, accesibles a los usuarios).
- Las *variables* que se *importan* de otros paquetes.
- Las *clases y métodos* =S3= y =S4= que deben registrarse.

El =NAMESPACE= controla la estrategia de búsqueda de variables que utilizan las funciones del paquete:
- En primer lugar, busca entre las creadas localmente (por el código de la carpeta =R/=).
- En segundo lugar, busca entre las variables importadas explícitamente de otros paquetes.
- En tercer lugar, busca en el =NAMESPACE= del paquete =base=.
- Por último, busca siguiendo el camino habitual (usando =search()=).
#+begin_src R :exports both :results output
search()
#+end_src
*** Manejo de variables
- Exportar variables:
  #+begin_src R :eval no
  export(f, g)
  #+end_src
  Esto asegura que las variables =f= y =g= sean accesibles desde fuera del paquete.
- Importar *todas* las variables de otro paquete:
  #+begin_src R :eval no
  import(pkgExt)
  #+end_src
- Importar variables *concretas* de otro paquete:
  #+begin_src R :eval no
  importFrom(pkgExt, var1, var2)
  #+end_src
*** Manejo de clases y métodos
- Para registrar un *método* para una *clase* determinada:
  #+begin_src R :eval no
  S3method(print, myClass)
  #+end_src
  Esto permite definir cómo se imprimen objetos de la clase =myClass=
- Para los paquetes que utilizan clases y métodos =S4=, es necesario agregar una dependencia explícita en el archivo *DESCRIPTION*:
#+begin_src R :eval no
  import("methods")
#+end_src
- Para registrar clases =S4=:
#+begin_src R :eval no
  exportClasses(class1, class2)
#+end_src
- Para registrar métodos =S4=:
#+begin_src R :eval no
  exportMethods(method1, method2)
#+end_src
- Para importar métodos y clases =S4= de otro paquete:
#+begin_src R :eval no
  importClassesFrom(package, ...)
  importMethodsFrom(package, ...)
#+end_src
** Documentación
label:subsec:documentacion
La documentación en R sigue un formato específico llamado =Rd= (/R documentation/), que está inspirado en LaTex. Cada función, método o clase del paquete debe tener una página de documentación asociada, que generalmente se encuentra en el subdirectorio =man/=. Estas páginas incluyen información sobre el uso de la función, argumentos, detalles de la implementación y ejemplos de uso.
#+begin_export latex
\begin{examplebox}
#+end_export
#+begin_example
  \name{load}
  \alias{load}
  \title{Reload Saved Datasets}
  \description{
    Reload the datasets written to a file with the function
    \code{save}.
  }
  \usage{
    load(file, envir = parent.frame())
  }
  \arguments{
  \item{file}{a connection or a character string giving the
      name of the file to load.}
  \item{envir}{the environment where the data should be
      loaded.}
  }
  \seealso{
    \code{\link{save}}.
  }
  \examples{
    ## save all data
    save(list = ls(), file= "all.RData")
    
    ## restore the saved values to the current environment
    load("all.RData")
    
    ## restore the saved values to the workspace
    load("all.RData", .GlobalEnv)
  }
  \keyword{file}
#+end_example
#+begin_export latex
\end{examplebox}
#+end_export

El formato tiene varios componentes:
- *name*: El nombre de la función.
- *alias*: Nombres alternativos o alias de la función.
- *title*: Título breve que describe la función.
- *description*: Una descripción de lo que hace la función.
- *usage*: La sintaxis de la función de lo que hace la función.
- *arguments*: Explicación de los argumentos que recibe la función.
- *seealso*: Enlaces a funciones relacionadas.
- *examples*: Ejemplos de cómo utilizar la función.

Esta estructura de documentación permite a los usuarios comprender rápidamente cómo utilizar las funciones del paquete y verificar su funcionalidad con ejemplos prácticos.

* Footnotes

[fn:1] Todas las funciones recogidas en este capítulo, están descritas en el manual de uso del paquete =solaR2=, el cual, está disponible en el apendice ref:chap:manual de este documento.

[fn:2] Cuando la hora solar verdadera excede los ángulos en los que amanece y anochece ($|\omega|>=|\omega_s|$), el Sol queda por debajo de la línea del horizonte, por lo que es de noche.

[fn:3] $\gamma_s=asin(cos(\theta_s))$.

[fn:4] Pese a que este proyecto trate de "desligarse" del paquete =zoo=, sigue siendo un paquete muy extendido. Por lo que es interesante tener una función así para que los usuarios tengan una mayor flexibilidad.

[fn:5] La red SiAR (Sistema de Información Agroclimática para el Regadio) es una infraestructura que captura, registra y divulga los datos climáticos necesarios para el cálculo de la demanda hídrica en las zonas de riego cite:siar23.

[fn:6] La API (Interfaz de Programación de Aplicaciones) que se usa para la función =readSIAR= está proporcionada por la propia red SIAR cite:siar23.

[fn:7] La interpolación IDW es un método de interpolación que estima el valor de un punto desconocido basado en los valores conocidos de puntos cercanos. Los puntos más cercanos tienen más peso en la estimación que los más lejanos, utilizando una relación inversa con la distancia.

[fn:8] la tencología de concentración fotovoltaica funciona gracias a unos dispositivos ópticos que permiten concentrar la radiación solar sobre una célula fotovoltaica de tamaño reducido pero con una eficiencia muy superior alas células tradicionales. Con ello se consigue emplear menor cantidad de semiconductores reduciendo los costes.

[fn:9] Un esquema de numeración semántica es un sistema de versiones que sigue un patrón específico para asignar números a las versiones de software. Se utiliza para indicar claramente la magnitud de los cambios realizados y su impacto en la compatibilidad.  Una versión =major= o mayor se refiere a modificaciones grandes o incompatibles con versiones anteriores, =minor= o menor es una versión que incluye mejoras o nuevas funciones compatibles con versiones anteriores y =patch= o parche es una versión que incluye correcciones menores o mejoras que no afectan a la funcionalidad.
