#+PROPERTY: header-args:R :dir . :session *R* :exports both :results output
\chapter{Desarrollo del código}
label:chap:desarrollo-codigo
En la figura [[fig:prod-solar2]], se muestra el proceso de cálculo que sigue el paquete a la hora de obtener la estimación de la producción del sistema fotovoltaico.
#+ATTR_LATEX: :height 0.5\textheight :width 0.8\textwidth :options keepaspectratio
#+CAPTION: Proceso de cálculo de las funciones de =solaR2=
#+NAME: fig:prod-solar2
[[file:figuras/procedure.pdf]]
A la hora de estimar la producción, el programa sigue los siguientes procesos:
* Geometría solar
label:sec:geometria-solar
Para calcular la geometría que definen las posiciones de la Tierra y el Sol, =solaR2= se vale de una función constructora, =calcSol= [ref:subsec:calcsol], la cual mediante las funciones =fSolD= [ref:subsec:fsold] y =fSolI= [ref:subsec:fsoli] cálcula todos los ángulos y componentes que caracterizan la geometría solar.
#+CAPTION: Cálculo de la geometría solar mediante la función =calcSol=, la cual unifica las funciones =fSolD= y =fSolI= resultando en un objeto clase =Sol= el cual contiene toda la información geométrica necesaria para realizar las siguientes estimaciones. label:fig:calcSol
#+ATTR_LATEX: :height 0.5\textheight :width \textwidth :options keepaspectratio
[[file:figuras/calcSol.pdf]]

Como se puede ver en la figura ref:fig:calcSol, =calcSol= funcia gracias a las siguientes funciones:
- =fSolD=: la cual, a partir de la latitud (\(\phi\)), calcula la geometría a nivel diario, es decir, los ángulos y componentes que se pueden calcular en cada día independiente.

  Estas son:
  - Declinación (\(\delta\)): calculada a partir de la función =declination=[fn:1].
  - Excentricidad (\(\epsilon_o\)): obtenida mediante la función =eccentricity=.
  - Ecuación del tiempo (\(EoT\)): obtenida mediante la función =eot=.
  - Ángulo del amanecer (\(\omega_s\)): calculada a partir de la función =sunrise=.
  - Irradiancia diaria extra-atmosférica (\(B_{0d}(0)\)): obtenida a paritr de la función =bo0d=.
#+begin_src R :exports none
  library(solaR2)
  library(zoo)
  library(httr2)
  library(jsonlite)
  setwd('TFG')
#+end_src

#+RESULTS:
#+begin_example
Cargando paquete requerido: data.table
data.table 1.15.4 using 6 threads (see ?getDTthreads).  Latest news: r-datatable.com
Cargando paquete requerido: lattice
Cargando paquete requerido: latticeExtra
Time Zone set to UTC.

Adjuntando el paquete: 'zoo'

The following objects are masked from 'package:data.table':

    yearmon, yearqtr

The following objects are masked from 'package:base':

    as.Date, as.Date.numeric
#+end_example

#+begin_src R 
lat <- 37.2
BTd <- fBTd(mode = 'prom')
solD <- fSolD(lat = lat, BTd = BTd)
show(solD)
#+end_src

  Además, =fSolD= permite seleccionar el método de cáculo entre los propuestos por 4 autores diferentes (=cooper= cite:Cooper1969, =spencer= cite:Spencer1971, =strous= cite:Strous2011, =michalsky= cite:Michalsky1988)(el valor por defecto es =michalsky=):
#+begin_src R 
solD_cooper <- fSolD(lat = lat, BTd = BTd, method = 'cooper')
show(solD_cooper)
#+end_src
#+begin_src R
solD_spencer <- fSolD(lat = lat, BTd = BTd, method = 'spencer')
show(solD_spencer)
#+end_src
#+begin_src R
solD_strous <- fSolD(lat = lat, BTd = BTd, method = 'cooper')
show(solD_strous)
#+end_src
- =fSolI=: toma los resultados obtenidos en =fSolD= y calcula la geometría a nivel intradiario, es decir, aquella que se puede calcular en unidades de tiempo menores a los días.
  Estas son:
  - La hora solar o tiempo solar verdadero (\(\omega\)): calculada a partir de la función =sunHour=.
  - Los momentos del día en los que es de noche (\(night\)): calculada a partir del resultado anterior y de el ángulo del amanecer (cálculada en =fSolD=)[fn:2].
  - El coseno del ángulo cenital solar (\(cos(\theta_{zs})\)): obtenida a partir de la función =zenith=.
  - La altura solar (\(\gamma_s\)): obtenida a partir del resultado anterior[fn:3].
  - El ángulo acimutal solar (\(\theta_{zs}\)): calculada mediante la función =azimuth=.
  - La irradiancia extra-atmosférica (\(B_0(0)\)): calculada mediante el coseno del ángulo cenital, la constante solar (\(B_0\)) y la excentridad (cálculada en =fSolD=) [ecuación ref:eq:irrad_horiz].
#+begin_src R
solI <- fSolI(solD = solD[1], sample = 'hour') #Computo solo un día a fin mejorar la visualización
show(solI)
#+end_src

  Además, como los datos nocturnos aportan poco a los cálculos que atañen a este proyecto, =fSolI= presenta la posibilidad de eliminar estos datos con el argumento =keep.night=.
#+begin_src R
solI_nigth <- fSolI(solD = solD[1], sample = 'hour', keep.night = FALSE)
show(solI_nigth)
#+end_src
  Aparte, en vez de identificar el intervalo intradiario (con el argumento =sample=), se puede dar directamente la base temporal intradiaria.
#+begin_src R
BTi <- fBTi(BTd, sample = 'hour')
solI_BTi <- fSolI(solD, BTi = BTi)
show(solI_BTi)
#+end_src
  También, se puede indicar que no realice las correcciones de la ecuación del tiempo.
#+begin_src R
solI_EoT <- fSolI(solD = solD, BTi = BTi, EoT = FALSE)
show(solI_EoT)
#+end_src

Finalmente, estas dos funciones, como se muestra en la figura ref:fig:calcSol, convergen en la función =calcSol=, dando como resultado un objeto de clase =Sol=. Este objeto muestra un resumen de ambos elementos junto con la latitud de los cálculos.
#+begin_src R
sol <- calcSol(lat = lat, BTd = BTd, sample = 'hour')
show(sol)
#+end_src

* Datos meteorológicos
label:sec:datos-meteorologicos
Para el procesamiento de datos meteorologicos, =solaR2= provee una serie de funciones[fn:4] que son capaces de leer todo tipo de datos. Estos datos se procesan y se almacenan en un objeto de tipo =Meteo= tal y como se ve en la figura ref:fig:meteo. Estas funciones son:
#+CAPTION: Los datos meteorologicas se pueden leer mediante las funciones =readG0dm=, =readBD=, =dt2Meteo=, =zoo2Meteo= y =readSIAR= las cuales procesan estos datos y los almacenan en un objeto de clase =Meteo=. label:fig:meteo
#+ATTR_LATEX: :height 0.5\textheight :width \textwidth :options keepaspectratio 
file:figuras/meteo.pdf
- =readG0dm=: Esta función construye un objeto =Meteo= a partir de 12 valores de medias mensuales de irradiación.
#+begin_src R
G0dm = c(2.766,3.491,4.494,5.912,6.989,7.742,
         7.919,7.027,5.369,3.562,2.814,2.179) * 1000;
Ta = c(10, 14.1, 15.6, 17.2, 19.3, 21.2,
       28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
BD <- readG0dm(G0dm = G0dm, Ta = Ta, lat = 37.2)
show(BD)
#+end_src
- =readBD=: Esta familia de funciones puede leer ficheros de datos y transformarlos en un objeto de clase =Meteo=. Se dividen en:
  - =readBDd=: Procesa datos meteorológicos de tipo diarios.
  #+begin_src R
  ## Se utiliza un archivo alojado en el
  ## github del tutor de este proyecto 
  myURL <-"https://raw.githubusercontent.com/oscarperpinan/R/master/data/aranjuez.csv"
  download.file(myURL, 'data/aranjuez.csv', quiet = TRUE)
  BDd <- readBDd(file = 'data/aranjuez.csv', lat = lat,
		 format = '%Y-%m-%d', header = TRUE,
		 fill = TRUE, dec = '.', sep = ',', dates.col = '',
		 ta.col = 'TempAvg', g0.col = 'Radiation', keep.cols = TRUE)
  show(BDd)
  #+end_src
  - =readBDi=: Procesa datos meteorológicos de tipo intradiarios.
  #+begin_src R
    myURL <- "https://raw.githubusercontent.com/oscarperpinan/R/master/data/NREL-Hawaii.csv"
    download.file(myURL, 'data/NREL-Hawaii.csv', quiet = TRUE)
    BDi <- readBDi(file = 'data/NREL-Hawaii.csv', lat = 19,
		   format = "%d/%m/%Y %H:%M", header = TRUE,
		   fill = TRUE, dec = '.', sep = ',',
		   dates.col = 'DATE', times.col = 'HST',
		   ta.col = 'Air Temperature [deg C]',
		   g0.col = 'Global Horizontal [W/m^2]',
		   keep.cols = TRUE)
    show(BDi)
  #+end_src
- =dt2Meteo=: Transforma un =data.table= o =data.frame= en un objeto de clase =Meteo=.
#+begin_src R
  data(helios)
  names(helios) <- c('Dates', 'G0d', 'TempMax', 'TempMin')
  helios_meteo <- dt2Meteo(file = helios, lat = 40, type = 'bd')
  show(helios_meteo)
#+end_src  
- =zoo2Meteo=: Transforma un objeto de clase =zoo=[fn:5] en un objeto de clase =Meteo=.
#+begin_src R
  library(zoo)
  bd_zoo <- read.csv.zoo('data/aranjuez.csv')
  BD_zoo <- zoo2Meteo(file = bd_zoo, lat = 40)
  show(BD_zoo)
#+end_src
- =readSIAR=: Esta función es capaz de extraer información de la red SIAR y transformarlo en un objeto de clase =Meteo=.
#+begin_src R 
  library(httr2)
  library(jsonlite)
  bd_SIAR <- readSIAR(Lat = 40.40596822621351, Lon = -3.70038308516172,
		      ## Ubicación de la Escuela Técnica Superior
		      ## de Ingeniería y Diseño Industrial (ETSIDI)
		      inicio = '2023-09-01', final = '2024-08-01',
		      tipo = 'Mensuales', n_est = 3)
  show(bd_SIAR)
#+end_src
  Esta función tiene dos argumentos importantes:
  - =tipo=: La API SIAR[fn:6] permite tener 4 tipos de registros: =Mensuales=, =Semanales=, =Diarios= y =Horarios=.
  - =n_est=: Con este argumento, la función es capaz de localizar el número seleccionado de estaciones más proximas a la ubicación dada, y obtener los datos individuales de cada una de ellas. Una vez obtenidos estos datos realiza una interpolación de distancia inversa ponderada (IDW) y entrega un solo resultado. Es importante añadir que la API SIAR tiene una limitación a la solicitud de registros que se le hace cada minuto, por lo que esta función cuenta con un comprobante para impedir que el usuario exceda este límite.
      
* Radiación en el plano horizontal
label:sec:radiacion-plano-horizontal
Una vez se ha calculado la geometría solar (sección ref:sec:geometria-solar) y se han procesado los datos meteorológicos (sección ref:sec:datos-meteorologicos), es necesario calcular la radiación en el plano horizontal. Para ello, =solaR2= cuenta con la función =calcG0= [ref:subsec:calcg0] la cual mediante las funciones =fCompD= [ref:subsec:fcompd] y =fCompI= [ref:subsec:fcompi] procesan los objetos de clase =Sol= y clase =Meteo= para dar un objeto de tipo =G0=.

Como se puede ver en la figura ref:fig:calcg0, =calcG0= funciona gracias a las siguientes funciones:
#+CAPTION: Cálculo de la radiación incidente en el plano horizontal mediante la función =calcG0=, la cual procesa un objeto clase =Sol= y otro clase =Meteo= mediante las funciones =fCompD= y =fCompI= resultando en un objeto clase =G0=. :label:fig:calcg0
#+ATTR_LATEX: :width \textwidth :height 0.5\textheight :options keepaspectratio
file:figuras/calcg0.pdf
- =fCompD=: La cual calcula todas las componentes de la irradiación diaria en una superficie horizontal mediante regresiones entre los parámetros del índice de claridad y la fracción difusa.
  Para ello se pueden usar varias correlaciones dependiendo del tipo de datos:
  - Mensuales:
  #+begin_src R
  lat <- 37.2
  BTd <- fBTd(mode = 'prom')
  solD <- fSolD(lat, BTd)
  G0d <- c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,7.027,5.369,3.562,2.814,2.179) * 1000
  compD_page <- fCompD(sol = solD, G0d = G0d, corr = "Page")
  compD_page
  #+end_src
  #+begin_src R
  compD_lj <- fCompD(sol = solD, G0d = G0d, corr = "LJ")
  compD_lj
  #+end_src
  - Diarios:
  #+begin_src R 
  G0d <- readSIAR(Lat = 40.40596822621351, Lon =-3.70038308516172,
		  inicio = '2024-07-15', final = '2024-08-01',
		  tipo = 'Diarios', n_est = 3)
  sol <- calcSol(lat, BTd = indexD(G0d))
  compD_cpr <- fCompD(sol = sol, G0d = G0d, corr = "CPR")
  compD_cpr
  #+end_src
  #+begin_src R
  compD_ekdd <- fCompD(sol = sol, G0d = G0d, corr = 'EKDd')
  compD_ekdd
  #+end_src
  #+begin_src R
  compD_climedd <- fCompD(sol = sol, G0d = G0d, corr = 'CLIMEDd')
  compD_climedd
  #+end_src
  También, se puede aportar una función de correlación propia.
  #+begin_src R
  f_corrd <- function(sol, G0d){
    ## Función CLIMEDd
      Kt <- Ktd(sol, G0d)
      Fd=(Kt<=0.13)*(0.952)+
      (Kt>0.13 & Kt<=0.8)*(0.868+1.335*Kt-5.782*Kt^2+3.721*Kt^3)+
	(Kt>0.8)*0.141
    return(data.table(Fd, Kt))
  }
  compD_user <- fCompD(sol = sol, G0d = G0d, corr = 'user', f = f_corrd)
  compD_user
  #+end_src
  Por último, si =G0d= ya contiene todos los componentes, se puede especifica que no haga ninguna correlación.
  #+begin_src R
  compD_none <- fCompD(sol = sol, G0d = compD_user, corr = 'none')
  compD_none
  #+end_src
- =fCompI=: calcula, en base a los valores de irradiación diaria, todas las componentes de irradiancia. Se vale de dos procedimientos en base al tipo de argumentos que toma:
  - =compD=: Si recibe un =data.table= resultado de =fCompD=, calcula las relaciones entre las componentes de irradiancia e irradiación de las componentes de difusa y global, obteniendo con ellas un perfil de irradiancias [ref:sec:radiacion-superficies-inclinadas] (las irradiancias global y difusa salen de estas relaciones, mientras que la directa surge por diferencia entre las dos).
  #+begin_src R
  sol <- calcSol(lat = 37.2, BTd = fBTd(mode = 'prom'),
		 sample = 'hour', keep.night = FALSE)
  G0d <- c(2.766,3.491,4.494,5.912,6.989,7.742,7.919,
	    7.027,5.369,3.562,2.814,2.179) * 1000
  compD <- fCompD(sol = sol, G0d = G0d, corr = 'CPR')
  compI <- fCompI(sol = sol, compD = compD)
  show(compI)
  #+end_src
  - =G0I=: Este argumento recibe datos de irradiancia, para después, poder aplicar las correcciones indicadas en el argumento =corr=.
  #+begin_src R
  G0I <- compI$G0
  compI_ekdh <- fCompI(sol = sol, G0I = G0I, corr = 'EKDh')
  show(compI_ekdh)
  #+end_src
  #+begin_src R
  compI_brl <- fCompI(sol = sol, G0I = G0I, corr = 'BRL')
  show(compI_brl)
  #+end_src
  #+begin_src R
  compI_climedh <- fCompI(sol = sol, G0I = G0I, corr = 'CLIMEDh')
  show(compI_climedh)
  #+end_src
  Como con =fCompD=, se puede añadir una función correctora propia.
  #+begin_src R
  f_corri <- function(sol, G0i){
    ## Función CLIMEDh
    Kt <- Kti(sol, G0i)
    Fd=(Kt<=0.21)*(0.995-0.081*Kt)+
      (Kt>0.21 & Kt<=0.76)*(0.724+2.738*Kt-8.32*Kt^2+4.967*Kt^3)+
      (Kt>0.76)*0.180
    return(data.table(Fd, Kt))
  }
  compI_user <- fCompI(sol = sol, G0I = G0I, corr = 'user', f = f_corri)
  show(compI_user)
  #+end_src
  Y además, se puede no añadir correlación.
  #+begin_src R
  G0I <- compI_user
  compI_none <- fCompI(sol = sol, G0I = G0I, corr = 'none')
  show(compI_none)
  #+end_src
  Por útlimo, esta función incluye un argumento extra, =filterG0= que cuando su valor es =TRUE=, elimina todos aquellos valores de irradiancia que son mayores que la irradiancia extra-atmosfércia (ya que es incoherente que la irradiancia terrestre sea mayor que la extra-terrestre)

Estas dos funciones, como se muestra en la figura ref:fig:calcg0, convergen en la función constructora =calcG0=, dando como resultado un objeto de clase =G0=. Este objeto muestra la media mensual de la irradiación diaria y la irradiación anual. Aparte, incluye los resultados de =fCompD= y =fCompI= y los objetos =Sol= y =Meteo= de los que parte.

Como argumento más importante está =modeRad=, el cual selecciona el tipo de datos que introduce el usuario en el argumento =dataRad=. Estos son:
- Medias mensuales.
  #+begin_src R
  G0dm <- c(2.766, 3.491, 4.494, 5.912, 6.989, 7.742, 7.919,
	    7.027, 5.369, 3.562, 2.814, 2.179) * 1000
  Ta <- c(10, 14.1, 15.6, 17.2, 19.3, 21.2,
	 28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
  prom <- data.table(G0dm, Ta) 
  g0_prom <- calcG0(lat, modeRad = 'prom', dataRad = prom)
  show(g0_prom)
  #+end_src
- Generación de secuencias diarias mediante matrices de transición de Markov.
  #+begin_src R
  g0_aguiar <- calcG0(lat, modeRad = 'aguiar', dataRad = prom)
  show(g0_aguiar)
  #+end_src
- Diarios.
  #+begin_src R
  bd <- as.data.tableD(g0_aguiar)
  g0_bd <- calcG0(lat, modeRad = 'bd', dataRad = bd)
  show(g0_bd)
  #+end_src
- Intradiarios
  #+begin_src R
  bdI <- as.data.tableI(g0_aguiar)
  g0_bdI <- calcG0(lat, modeRad = 'bdI', dataRad = bdI)
  show(g0_bdI)
  #+end_src

* Radiación efectiva en el plano del generador
label:sec:radiacion-efectiva-plano-generador
Teniendo la radiación incidente en plano horizontal (sección ref:sec:radiacion-plano-horizontal), se puede calcular la radiación efectiva incidente en el plano del generador. Para ello, =solaR2= cuenta con la función =calcGef= [ref:subsec:calcgef] la cual mediante las funciones =fInclin= y =calcShd= procesa un objeto de clase =G0= para obtener un objeto =Gef=.

Como se puede ver en la figura ref:fig:calcgef, =calcGef= funciona gracias a las siguientes funciones:
#+CAPTION: Cálculo de la radiación efectiva incidente en el plano del generador mediante la función =calcGef=, la cual emplea la función =fInclin= para el computo de las componentes efectivas, la función =fTheta= que provee a la función anterior los ángulos necesarios para su computo y la función =calcShd= que reprocesa el objeto de clase =Gef= resultante, añadiendole el efecto de las sombras producidas entres módulos. label:fig:calcgef
#+ATTR_LATEX: :width \textwidth :height 0.5\textheight :options keepaspectratio
file:figuras/calcgef.pdf
- =fTheta=: la cual, partiendo del ángulo de inclinación (\(\beta\)) y la orientación (\(\alpha\)), calcula el ángulo de inclinación en cada instante (\(\beta\)), el ángulo azimutal (\(\psi_s\)) y el coseno del ángulo de incidencia  de la radiación solar en la superficie (\(cos(\theta_s)\)).
  Como principal argumento tiene =modeTrk=, el cual determina el sistema de seguimiento que tiene el sistema:
  - =fixed=: para sistemas estáticos.
  #+begin_src R
  BTd <- fBTd(mode = 'prom')[6] 
  sol <- calcSol(lat, BTd = BTd, keep.night = FALSE)
  beta <- lat - 10
  alfa <- 0
  angGen_fixed <- fTheta(sol = sol, beta = beta, alfa = alfa,
		   modeTrk = 'fixed')
  show(angGen_fixed)
  #+end_src
  - =two=: para sistemas de seguimiento de doble eje.
  #+begin_src R
  angGen_two <- fTheta(sol = sol, beta = beta, alfa = alfa,
		       modeTrk = 'two')
  show(angGen_two)
  #+end_src
  - =horiz=: para sistemas de seguimiento horizontal Norte-Sur.
  #+begin_src R
  angGen_horiz <- fTheta(sol = sol, beta = beta, alfa = alfa,
			 modeTrk = 'horiz')
  show(angGen_horiz)
  #+end_src
  También, tiene un argumento =BT= que indica cuando se usa la técnica de backtracking para un sistema horizontal Norte-Sur. Para funcionar, necesita de los argumentos =struct=, el cual presenta una lista con la altura de los módulos, y =dist=, el cual presenta un =data.frame= (o =data.table=) con la distancia que separa los módulos en la dirección Este-Oeste.
  #+begin_src R
  struct <- list(L = 1)
  distances <- data.table(Lew = 2)
  angGen_BT <- fTheta(sol = sol, beta = beta, alfa = alfa,
		      modeTrk = 'horiz', BT = TRUE,
		      struct = struct, dist = distances)
  show(angGen_BT)
  #+end_src
- =fInclin=: la cual, partiendo del resultado de =fTheta= y de un objeto de clase =G0=, cálcula la irradiancia solar incidente en una superficie inclinada junto con los efectos del ángulo de incidencia y la suciedad para obtener la irradiancia efectiva.
  Como argumentos principales están:
  - =iS=: permite seleccionar entre 4 valores del 1 al 4 correspondientes al grado de suciedad del módulo. Siendo 1 limpio y 4 alto y basandose en los valores de la tabla ref:tab:coef-perd calcula la irradiancia efectiva. Por defecto tiene valor 2 (grado de suciedad bajo).
  #+begin_src R
  compI <- calcG0(lat, dataRad = prom, keep.night = FALSE)
  sol <- calcSol(lat, BTi = indexI(compI))
  angGen <- fTheta(sol = sol, beta = beta, alfa = alfa)
  inclin_limpio <- fInclin(compI = compI, angGen = angGen, iS = 1)
  show(inclin_limpio)
  #+end_src
  #+begin_src R
  inclin_sucio <- fInclin(compI = compI, angGen = angGen, iS = 4)
  show(inclin_sucio)
  #+end_src
  - =alb= Correspondiente al coeficiente de reflexión del terreno para la irradiancia de albedo. Por defecto tiene un valor de 0,2 (valor aceptable para un terreno normal).
  #+begin_src R
  inclin_alb0 <- fInclin(compI = compI, angGen = angGen, alb = 0)
  show(inclin_alb0)
  #+end_src
  #+begin_src R
  inclin_alb1 <- fInclin(compI = compI, angGen = angGen, alb = 1)
  show(inclin_alb1)
  #+end_src
  Además, cuenta con dos argumentos adicionales, =horizBright=, el cual, cuando su valor es =TRUE= (el que tiene por defecto), realiza una corrección de la radiación difusa cite:REINDL19909, y =HCPV=, es el acrónimo de *High Concentration PV system*[fn:7] (sistema fotovoltaico de alta concentración) que cuando su valor es =TRUE= (por defecto está puesto en =FALSE=), anula los valores de radiación difusa y de albedo.
  #+begin_src R
  inclin_horizBright <- fInclin(compI = compI, angGen = angGen,
				horizBright = FALSE)
  show(inclin_horizBright)
  #+end_src
  #+begin_src R
  inclin_HCPV <- fInclin(compI = compI, angGen = angGen,
			 HCPV = TRUE)
  show(inclin_HCPV)
  #+end_src

Finalmente, esta función le otorga estos datos a la función =calcGef= para que produzca un objeto de clase =Gef= como resultado. Esta función tiene como argumentos principales los mismos que los que tiene =calcG0= ref:sec:radiacion-plano-horizontal, es decir, =modeRad= y =dataRad=. Y además, como es lógico, con todos los argumentos mencionados con anterioridad en =fTheta= y =fInclin=.
#+begin_src R
gef_prom <- calcGef(lat = lat, modeTrk = 'two', modeRad = 'prom',
                    dataRad = prom,
                    beta = lat-10, alfa = 0,
                    iS = 2, alb = 0.2,
                    horizBright = TRUE, HCPV = FALSE)
show(gef_prom)
#+end_src
Sin embargo, como argumento importante está =modeShd=, el cual permite incluir el efecto de las sombras entre módulos al objeto =Gef= mediante el uso de la función =calcShd=. Esta opción añade las variables =Gef0=, =Def0= y =Bef0= las cuales son las componentes de radiación efectiva previas a aplicar el efecto de las sombras con el fin de poder comparar.
#+begin_src R
struct <- list(W=23.11, L=9.8, Nrow=2, Ncol=8)
distances <- data.table(Lew=40, Lns=30, H=0)
gef_shd <- calcShd(radEf = gef_prom, modeShd = 'prom',
                   struct = struct, distances = distances)
show(gef_shd)
#+end_src
#+begin_src R
gef_shd2 <- calcGef(lat = lat, modeTrk = 'two', dataRad = prom,
                    modeShd = 'prom', struct = struct, distances = distances)
show(gef_shd2)
#+end_src
El argumento =modeShd= puede ser de distintas maneras:
- =area=: el efecto de las sombras se calcula como una reducción proporcional de las irradiancias difusa circunsolar y directa.
#+begin_src R
gef_shdarea <- calcGef(lat, modeTrk = 'two', dataRad = prom,
                       modeShd = 'area',
                       struct = struct, distances = distances)
show(gef_shdarea)
#+end_src
- =prom=: cuando =modeTrk= es =two=, se puede calcular el efecto de las sombras de un seguidor promedio.
#+begin_src R
gef_shdprom <- calcGef(lat, modeTrk = 'two', dataRad = prom,
                       modeShd = c('area', 'prom'),
                       struct = struct, distances = distances)
show(gef_shdprom)
#+end_src
- =bt=: cuando =modeTrk= es =horiz=, se puede calcular el efecto del /backtracking/ en las sombras.
#+begin_src R
gef_shdhoriz <- calcGef(lat, modeTrk = 'horiz', dataRad = prom,
                        modeShd = 'area',
                        struct = struct, distances = distances)
show(gef_shdhoriz)
#+end_src
#+begin_src R
gef_shdbt <- calcGef(lat, modeTrk = 'horiz', dataRad = prom,
                        modeShd = c('area', 'bt'),
                        struct = struct, distances = distances)
show(gef_shdbt)
#+end_src
* Producción eléctrica de un SFCR
label:produccion-electrica-sfcr
Con la radiación efectiva, se puede estimar la producción eléctrica que va a tener un sistema fotovoltaico conectado a red. Esta estimación, se puede calcular mediante la función =prodGCPV= [ref:subsec:prodgcpv] la cual mediante la función =fProd= [ref:subsec:fprod] procesa un objeto de clase =Gef= y obtiene un objeto =ProdGCPV=.

Como se puede ver en la figura ref:fig:prodgcpv, =prodGCPV= funciona gracias a la siguiente función:
#+CAPTION: Estimación de la producción eléctrica de un SFCR mediante la función =prodGCPV=, la cual emplea la función =fProd= para el computo de la potencia a la entrada (\(P_{DC}\)), a la salida (\(P_{AC}\)) y el rendimiento (\(\eta_{inv}\)) del inversor. label:fig:prodgcpv
#+ATTR_LATEX: :width \textwidth :height \textheight :options keepaspectratio
file:figuras/prodgcpv.pdf
- =fProd=: simula el comportamiento de un sistema fotovoltaico conectado a red bajo diferentes condiciones de temperatura e irradiancia. Tiene los siguientes argumentos:
  - =inclin=: puede ser tanto un objeto de clase =Gef= como un =data.frame= (o =data.table=). Sin embargo, si es un =data.frame=, debe contener como mínimo una columna para =Gef= y otra para =Ta=
  - =module=: una lista de valores numéricos con la información sobre el módulo fotovoltaico:
    - =Vocn=: tensión de circuito abierto en STC (\(V_{oc}^*\))(condiciones estandar de médida). Por defecto, tiene un valor de \(57.2V\).
    - =Iscn=: corriente de cortocircuito en STC (\(I_{sc}^*\)). Por defecto, tiene un valor de \(4.7A\).
    - =Vmn=: tensión en el punto de máxima potencia en STC (\(I_{MPP}^*\)). Por defecto, tiene un valor de \(46.08V\).
    - =Imn=: corriente de cortocircuito en STC (\(I_{MPP}^*\)). Por defecto, tiene un valor de \(4.35A\)).
    - =Ncs=: número de células en serie dentro del módulo. Por defecto, tiene un valor de 96.
    - =Ncp=: número de células en paralelo dentro del módulo. Por defecto, tiene un valor de 1.
    - =CoefVT=: coeficiente de disminución de la tensión  de cada célula con la temperatura (\(dV_{oc}/dT_c\)). Por defecto, tiene un valor de \(-0.0023 V/^\circ C\).
    - =TONC=: temperatura de operación nominal de célula (\(TONC\)). Por defecto, tiene un valor de \(47^\circ C\).
  - =generator=: lista de valores numéricos con la información sobre el generador:
    - =Nms=: número de módulos en serie. Por defecto, tiene un valor de 12.
    - =Nmp=: número de módulos en paralelo. Por defecto, tiene un valor de 11.
  - =inverter=: lista de valores númericos con la información del inversor DC/AC.
    - =Ki=: coeficientes de la curva de eficiencia del inversor. Se puede presentar en un vector de 3 valores (por defecto, =c(0.01, 0.025, 0.05)=) o una matriz de 9 valores (si tiene dependencia del voltage).
    - =Pinv=: potencia nominal del inversor. Por defecto, tiene un valor de \(25000 W\).
    - =Vmin=: mínima tensión del rango MPP del inversor. Por defecto, tiene un valor de \(420V\).
    - =Vmax=: máxima tensión del rango MPP del inversor. Por defecto, tiene un valor de \(750V\).
    - =Gumb=: irradiancia umbral de funcionamienot del inversor. Por defecto, tiene un valor de \(20W/m^2\).
  - =effSys=: una lista de valores numéricos con la información sobre las pérdidas del sistema.
    - =ModQual=: tolerancia media del set de módulos (\(\%\)). Por defecto, tiene un valor de 3.
    - =ModDisp=: pérdidas por dispersión en los módulos (\(\%\)). Por defecto, tiene un valor de 2.
    - =OhmDC=: pérdidas por efecto Joule en el cableado de DC (\(\%\)). Por defecto, tiene un valor de 1.5.
    - =OhmAC=: pérdidas por efecto Joule en el cableado de AC (\(\%\)). Por defecto, tiene un valor de 1.5.
    - =MPP=: error promedio del algoritmo de búsqueda del MPP del inversor (\(\%\)). Por defecto, tiene un valor de 1.
    - =TrafoMT=: pérdidas por el transformador MT (\(\%\)). Por defecto, tiene un valor de 1.
    - =Disp=: pérdidas por las paradas del sistema (\(\%\)). Por defecto, tiene un valor de 0.5.
#+begin_src R
inclin <- calcGef(lat, dataRad = prom, keep.night = FALSE)
module <- list(Vocn=57.6, Iscn=4.7, Vmn=46.08, Imn=4.35,
               Ncs=96, Ncp=1, CoefVT=0.0023, TONC=47)
generator <- list(Nms=12, Nmp=11)
inverter <- list(Ki=c(0.01, 0.025, 0.05), Pinv=25000,
                 Vmin=420, Vmax=750, Gumb=20)
effSys <- list(ModQual=3, ModDisp=2, OhmDC=1.5, OhmAC=1.5,
               MPP=1, TrafoMT=1, Disp=0.5)
prod <- fProd(inclin = inclin, module = module,
              generator = generator, inverter = inverter,
              effSys = effSys)
show(prod)
#+end_src

Esta función brinda estos datos a la función =prodGCPV= para que produzca un objeto de clase =ProdGCPV= como resultado. Esta función tiene como argumentos principales los mismo que =calcGef=, ya que parte de un objeto tipo =Gef=, y los argumentos de la función =fProd=.
#+begin_src R
prodFixed <- prodGCPV(lat, modeTrk = 'fixed', dataRad = prom)
show(prodFixed)
#+end_src
#+begin_src R
prod2x <- prodGCPV(lat, modeTrk = 'two', dataRad = prom)
show(prod2x)
#+end_src
#+begin_src R
prodHoriz <- prodGCPV(lat, modeTrk = 'horiz', dataRad = prom)
show(prodHoriz)
#+end_src

* Producción eléctrica de un SFB
De igual forma que en el apartado anterior, se puede estimar la producción eléctrica de un sistema fotovoltaico de bombeo.

Como se puede ver en la figura ref:fig:prodpvps, =prodPVPS= funciona gracias a la siguiente función:
#+CAPTION: Estimación de la producción eléctrica de un SFB mediante la función =prodPVPS=, la cual emplea la función =fPump= para el computo del rendimiento de las diferentes parte de una bomba centrífuga alimentada por un convertidor de frecuencia. label:fig:prodpvps
#+ATTR_LATEX: :width \textwidth :height 0.5\textheight :options keepaspectratio
file:figuras/prodpvps.pdf
- =fPump=: calcula el rendimiento de las diferentes partes de una bomba centrífuga alimentada por un convertidor de frecuencia siguiendo las leyes de afinidad. Tiene solo dos argumentos:
  - =pump=: lista que contiene los parametros de la bomba que va a ser simulada. Puede ser una fila de =pumpCoef=:
    #+begin_src R
      CoefSP8A44 <- pumpCoef[Qn == 8 & stages == 44]
      show(CoefSP8A44)
    #+end_src
  - =H=: el salto manometrico total.
  #+begin_src R
    fSP8A44 <- fPump(pump = CoefSP8A44, H = 40)
  #+end_src
  Obtiene como resultado los siguientes valores y funciones:
  - =lim=: rango de valores de la potencia eléctrica de salida.
    #+begin_src R
      show(fSP8A44$lim)
    #+end_src
  - =fQ=: función que relaciona el caudal con la potencia eléctrica.
    #+begin_src R
      show(fSP8A44$fQ)
    #+end_src
  - =fPb=: función que relaciona la potencia del eje de la bomba con la potencia eléctrica del motor.
    #+begin_src R
      show(fSP8A44$fPb)
    #+end_src
  - =fPh=: función que relaciona la potencia hidráulica con la potencia eléctrica del motor.
    #+begin_src R
      show(fSP8A44$fPh)
    #+end_src
  - =fFreq=: función que relaciona la frecuencia con la potencia eléctrica del motor.
    #+begin_src R
      show(fSP8A44$fFreq)
    #+end_src
  Se pueden realizar operaciones con este objeto:
  #+begin_src R
    SP8A44 = with(fSP8A44,{
      Pac = seq(lim[1],lim[2],l=10)
      Pb = fPb(Pac)
      etam = Pb/Pac
      Ph = fPh(Pac)
      etab = Ph/Pb
      f = fFreq(Pac)
      Q = fQ(Pac)
      result = data.table(Q,Pac,Pb,Ph,etam,etab,f)})
    show(SP8A44)
  #+end_src
  Está función entrega todos estos resultados a =prodPVPS= la cual calcula los resultados en base a la potencia del generador a simular, y devuleve un objeto de clase =ProdPVPS=.
  #+begin_src R
    prodsfb <- prodPVPS(lat, modeTrk = 'fixed', dataRad = prom,
			pump = CoefSP8A44, H = 40, Pg = SP8A44$Pac[10])
    show(prodsfb)
  #+end_src

* Optimización de distancias
label:optimizacion-distancias
Por último, el paquete =solaR2= contiene una función que permite calcular un conjunto de combinaciones de distancias entre los elementos de un sistema fotovoltaico conectado a red, con el fin de que el usuario posteriormente pueda optar cual es la opción mas rentable en base a los precios del cableado y de la ocupación del terreno.

Esta función es =optimShd=, la cual en base a una resolución (determinada por el argumento =res=, el cual, indica el incremento de la secuencia de distancias) obtiene la producción de cada combinación y la plasma en un objeto de clase =Shade=.
#+begin_src R
struct2x <- list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 3)
dist2x <- list(Lew = c(30, 45), Lns = c(20, 40))
ShdM2x <- optimShd(lat, dataRad = prom, modeTrk = 'two',
		   modeShd = c('area', 'prom'),
		   distances = dist2x, struct = struct2x,
		   res = 5,
                   prog = FALSE) #Se quita la barra de progreso
show(ShdM2x)
#+end_src
#+begin_src R
structHoriz = list(L = 4.83)
distHoriz = list(Lew = structHoriz$L * c(2,5))
Shd12HorizBT <- optimShd(lat = lat, dataRad = prom,
			 modeTrk = 'horiz',
			 betaLim = 60,
			 distances = distHoriz, res = 2,
			 struct = structHoriz,
			 modeShd = 'bt',
			 prog = FALSE) #Se quita la barra de progreso
show(Shd12HorizBT)
#+end_src
#+begin_src R
structFixed = list(L = 5)
distFixed = list(D = structFixed$L*c(1,3))
Shd12Fixed <- optimShd(lat = lat, dataRad = prom,
		       modeTrk = 'fixed',
		       distances = distFixed, res = 2,
		       struct = structFixed,
		       modeShd = 'area',
		       prog = FALSE) #Se quita la barra de progreso
show(Shd12Fixed)
#+end_src

* Métodos de visualización
label:sec:metodos-visualizacion
Una vez creados todos los objetos, para mejorar la visualización de los mismos, =solaR2= cuanta con una serie de métodos que ayudan a la compresión de los datos obtenidos.

** Datos meteorológicos
La clase =Meteo= cuenta con un método para =xyplot=.
#+begin_src R
lat <- 37.2
G0dm = c(2.766,3.491,4.494,5.912,6.989,7.742,
	 7.919,7.027,5.369,3.562,2.814,2.179) * 1000;
Ta = c(10, 14.1, 15.6, 17.2, 19.3, 21.2,
       28.4, 29.9, 24.3, 18.2, 17.2, 15.2)
BD <- readG0dm(G0dm = G0dm, Ta = Ta, lat = lat)
show(BD)
#+end_src
#+begin_src R :results output graphics :file "figuras/codigo-meteo.pdf" :width 8 :height 6
xyplot(BD)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-meteo.pdf

** Radiación en el plano horizontal
La clase =G0= cuenta con un método para =xyplot=.
#+begin_src R
g0 <- calcG0(lat, dataRad = BD)
show(g0)
#+end_src
#+begin_src R :results output graphics :file "figuras/codigo-g0.pdf" :width 8 :height 6
xyplot(g0)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-g0.pdf

Y con un método para =compare=.
#+begin_src R :results output graphics :file "figuras/codigo-g02.pdf" :width 8 :height 6
g02 <- calcG0(lat, dataRad = list(G0dm = G0dm*0.95, Ta = Ta))
compare(g0, g02)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-g02.pdf

** Radiación efectiva en el plano del generador
La clase =Gef= cuenta con un método para =xyplot=.
#+begin_src R
gef <- calcGef(lat, dataRad = BD)
show(gef)
#+end_src
#+begin_src R :results output graphics :file "figuras/codigo-gef.pdf" :width 8 :height 6
xyplot(gef)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-gef.pdf

Y con un método para =compare=.
#+begin_src R :results output graphics :file "figuras/codigo-gef2.pdf" :width 8 :height 6
gef2x <- calcGef(lat, modeTrk = 'two', dataRad = BD)
gefhoriz <- calcGef(lat, modeTrk = 'horiz', dataRad = BD)
compare(gef, gef2x, gefhoriz)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-gef2.pdf


** Producción eléctrica de un SFCR
La clase =ProdGCPV= cuenta con un método para =xyplot=.
#+begin_src R
prodFixed <- prodGCPV(lat, modeTrk = 'fixed', dataRad = BD)
show(prodFixed)
#+end_src
#+begin_src R :results output graphics :file "figuras/codigo-prodgcpv.pdf" :width 8 :height 6
xyplot(prodFixed)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-prodgcpv.pdf

Un método para =compare=.
#+begin_src R :results output graphics :file "figuras/codigo-prodgcpv2.pdf" :width 8 :height 6
prod2x <- prodGCPV(lat, modeTrk = 'two', dataRad = BD)
prodHoriz <- prodGCPV(lat, modeTrk = 'horiz', dataRad = BD)
compare(prodFixed, prod2x, prodHoriz)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-prodgcpv2.pdf

Y un método para =compareLosses=.
#+begin_src R :results output graphics :file "figuras/codigo-prodgcpv3.pdf" :width 8 :height 6
compareLosses(prodFixed, prod2x, prodHoriz)
#+end_src
#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-prodgcpv3.pdf

** Producción electrica de un SFB
La clase =ProdPVPS= cuenta con un método para =xyplot=.
#+begin_src R
pump <- prodPVPS(lat, dataRad = BD, pump = CoefSP8A44, H = 40, Pg = 5000)
show(pump)
#+end_src
#+begin_src R :results output graphics :file "figuras/codigo-prodpvps.pdf" :width 8 :height 6
xyplot(pump)
#+end_src
#+ATTR_LATEX: :with 0.8\textwidth
file:figuras/codigo-prodpvps.pdf

** Optimización de distancias
La clase =Shade= cuenta con un método para =shadeplot=.
#+begin_src R
struct2x = list(W = 23.11, L = 9.8, Nrow = 2, Ncol = 3)
dist2x = list(Lew = c(30, 45),Lns = c(20, 40))
ShdM2x <- optimShd(lat = lat, dataRad = prom, modeTrk = 'two',
                    modeShd = c('area','prom'),
                   distances = dist2x, struct = struct2x,
                   res = 5, prog = FALSE)
show(ShdM2x)
#+end_src
#+begin_src R :results output graphics :file "figuras/codigo-optimshd.pdf" :width 12 :height 9
shadeplot(ShdM2x)
#+end_src

#+RESULTS:

#+ATTR_LATEX: :width 0.8\textwidth
file:figuras/codigo-optimshd.pdf

* Footnotes

[fn:1] Todas las funciones mencionadas en este punto, se encuentran en el apartado ref:subsec:utils-angles.

[fn:2] Cuando la hora solar verdadera excede los ángulos en los que amanece y anochece ($|\omega|>=|\omega_s|$), el Sol queda por debajo de la línea del horizonte, por lo que es de noche.

[fn:3] $\gamma_s=asin(cos(\theta_s))$.

[fn:4] Las funciones comentadas en este apartado, se recogen en la sección ref:subsec:meteoreaders

[fn:5] Pese a que este proyecto trate de "desligarse" del paquete =zoo=, sigue siendo un paquete muy extendido. Por lo que es interesante tener una función así para que los usuarios tengan una mayor flexibilidad.

[fn:6] La API (Interfaz de Programación de Aplicaciones) que se usa para la función =readSIAR= está proporcionada por la propia red SIAR cite:siar23.

[fn:7] la tencología de concentración fotovoltaica funciona gracias a unos dispositivos ópticos que permiten concentrar la radiación solar sobre una célula fotovoltaica de tamaño reducido pero con una eficiencia muy superior alas células tradicionales. Con ello se consigue emplear menor cantidad de semiconductores reduciendo los costes.
